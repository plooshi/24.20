#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CraftingRuntime

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DataRegistry_structs.hpp"
#include "CraftingRuntime_structs.hpp"
#include "ModularGameplay_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"


namespace SDK
{

// Class CraftingRuntime.CraftingSpaceComponent
// 0x0020 (0x00C0 - 0x00A0)
class UCraftingSpaceComponent final : public UGameFrameworkComponent
{
public:
	struct FGameplayTagContainer                  CraftingSpaceTags;                                 // 0x00A0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CraftingSpaceComponent">();
	}
	static class UCraftingSpaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCraftingSpaceComponent>();
	}
};
static_assert(alignof(UCraftingSpaceComponent) == 0x000008, "Wrong alignment on UCraftingSpaceComponent");
static_assert(sizeof(UCraftingSpaceComponent) == 0x0000C0, "Wrong size on UCraftingSpaceComponent");
static_assert(offsetof(UCraftingSpaceComponent, CraftingSpaceTags) == 0x0000A0, "Member 'UCraftingSpaceComponent::CraftingSpaceTags' has a wrong offset!");

// Class CraftingRuntime.CraftingGlobals
// 0x0000 (0x0028 - 0x0028)
class UCraftingGlobals final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CraftingGlobals">();
	}
	static class UCraftingGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCraftingGlobals>();
	}
};
static_assert(alignof(UCraftingGlobals) == 0x000008, "Wrong alignment on UCraftingGlobals");
static_assert(sizeof(UCraftingGlobals) == 0x000028, "Wrong size on UCraftingGlobals");

// Class CraftingRuntime.CraftingObjectBGA
// 0x0070 (0x0AA0 - 0x0A30)
class ACraftingObjectBGA final : public ABuildingGameplayActor
{
public:
	uint8                                         Pad_A30[0x8];                                      // 0x0A30(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortInventory*                         Inventory;                                         // 0x0A38(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A40[0x18];                                     // 0x0A40(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereComponent_InteractionRange;                  // 0x0A58(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MenuWidget;                                        // 0x0A60(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       WidgetComponent_PotContents;                       // 0x0A88(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowCraftingUI;                                   // 0x0A90(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSendEventMessageOnLocalInteract;                  // 0x0A91(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A92[0x6];                                      // 0x0A92(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   CraftingObjectMesh;                                // 0x0A98(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleInteractionRangeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandleInteractionRangeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CraftingObjectBGA">();
	}
	static class ACraftingObjectBGA* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACraftingObjectBGA>();
	}
};
static_assert(alignof(ACraftingObjectBGA) == 0x000008, "Wrong alignment on ACraftingObjectBGA");
static_assert(sizeof(ACraftingObjectBGA) == 0x000AA0, "Wrong size on ACraftingObjectBGA");
static_assert(offsetof(ACraftingObjectBGA, Inventory) == 0x000A38, "Member 'ACraftingObjectBGA::Inventory' has a wrong offset!");
static_assert(offsetof(ACraftingObjectBGA, SphereComponent_InteractionRange) == 0x000A58, "Member 'ACraftingObjectBGA::SphereComponent_InteractionRange' has a wrong offset!");
static_assert(offsetof(ACraftingObjectBGA, MenuWidget) == 0x000A60, "Member 'ACraftingObjectBGA::MenuWidget' has a wrong offset!");
static_assert(offsetof(ACraftingObjectBGA, WidgetComponent_PotContents) == 0x000A88, "Member 'ACraftingObjectBGA::WidgetComponent_PotContents' has a wrong offset!");
static_assert(offsetof(ACraftingObjectBGA, bShowCraftingUI) == 0x000A90, "Member 'ACraftingObjectBGA::bShowCraftingUI' has a wrong offset!");
static_assert(offsetof(ACraftingObjectBGA, bSendEventMessageOnLocalInteract) == 0x000A91, "Member 'ACraftingObjectBGA::bSendEventMessageOnLocalInteract' has a wrong offset!");
static_assert(offsetof(ACraftingObjectBGA, CraftingObjectMesh) == 0x000A98, "Member 'ACraftingObjectBGA::CraftingObjectMesh' has a wrong offset!");

// Class CraftingRuntime.CraftingCheatManager
// 0x0000 (0x0028 - 0x0028)
class UCraftingCheatManager final : public UChildCheatManager
{
public:
	void StartSelfCrafting(class FName FormulaName);
	void ToggleFreeCrafting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CraftingCheatManager">();
	}
	static class UCraftingCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCraftingCheatManager>();
	}
};
static_assert(alignof(UCraftingCheatManager) == 0x000008, "Wrong alignment on UCraftingCheatManager");
static_assert(sizeof(UCraftingCheatManager) == 0x000028, "Wrong size on UCraftingCheatManager");

// Class CraftingRuntime.CraftingObjectComponent
// 0x04C0 (0x0560 - 0x00A0)
class UCraftingObjectComponent final : public UGameFrameworkComponent
{
public:
	TMulticastInlineDelegate<void(ECraftingObjectState CraftingState, float CraftingStateStartTime, float CraftingStateDuration)> CraftingObjectStateChanged;                        // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName& FormulaRowName, bool bIsCraftable)> OnFormulaCraftableChanged;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AFortPlayerController* Instigator, class AActor* CraftingObject, class FName& FormulaRowName)> OnCraftingSuccess;                                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FCraftingObjectRepStateData            CraftingObjectRepStateData;                        // 0x00D0(0x000C)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   CraftingFormulaRow;                                // 0x00DC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumToCraft;                                        // 0x00E0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AFortPlayerController>   CraftingInstigator;                                // 0x00E4(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortItemEntry>                 AllOfTheIngredientItems;                           // 0x00F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 NonConsumedIngredientItemIndices;                  // 0x0100(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FString                                 LastIngredientStringForAnalytics;                  // 0x0110(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LastFormulaStringForAnalytics;                     // 0x0120(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LastResultsStringForAnalytics;                     // 0x0130(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FItemAndCount>                  CraftingResults;                                   // 0x0140(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             WhileCraftingAbilitySpecHandle;                    // 0x0150(0x0004)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             OwnerCraftingAbilitySpecHandle;                    // 0x0154(0x0004)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CraftingObjectTag;                                 // 0x0158(0x0004)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CraftingObjectTags;                                // 0x0160(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CraftingTimeLength;                                // 0x0180(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ReadyTimeLength;                                   // 0x01A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         OverCraftingTimeLength;                            // 0x01D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ResettingTimeLength;                               // 0x01F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   OverCraftingLootTierKey;                           // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bTakeItemsAtCraftingStart : 1;                     // 0x0224(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bGiveIngredientsToCraftingObject : 1;              // 0x0224(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bGiveIngredientsToInstigator : 1;                  // 0x0224(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IngredientSpawnOffset;                             // 0x0228(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bGiveToCraftingObject : 1;                         // 0x0240(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bGiveResultToInstigator : 1;                       // 0x0240(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   OwnerCraftingAbility;                              // 0x0248(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   WhileCraftingAbility;                              // 0x0270(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CraftingFailedTags;                                // 0x0298(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class AFortPickup*                            PendingPickupCraftingItem;                         // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PendingPickupCraftingFormula;                      // 0x02C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortItemEntry                         PendingPickupCraftingItemEntry;                    // 0x02C8(0x01A0)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         PendingPickupHeldCount;                            // 0x0468(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0xEC];                                     // 0x046C(0x00EC)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          FreeCraftingEnabled;                               // 0x0558(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_559[0x7];                                      // 0x0559(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePickupCraftingItemPickedUp(class AFortPickup* PickUp, class AFortPawn* InteractingPawn, const class UFortWorldItemDefinition* WorldItemDefinition, const struct FVector& PickupLocation);
	void OnRep_CraftingObjectRepStateData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CraftingObjectComponent">();
	}
	static class UCraftingObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCraftingObjectComponent>();
	}
};
static_assert(alignof(UCraftingObjectComponent) == 0x000008, "Wrong alignment on UCraftingObjectComponent");
static_assert(sizeof(UCraftingObjectComponent) == 0x000560, "Wrong size on UCraftingObjectComponent");
static_assert(offsetof(UCraftingObjectComponent, CraftingObjectStateChanged) == 0x0000A0, "Member 'UCraftingObjectComponent::CraftingObjectStateChanged' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, OnFormulaCraftableChanged) == 0x0000B0, "Member 'UCraftingObjectComponent::OnFormulaCraftableChanged' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, OnCraftingSuccess) == 0x0000C0, "Member 'UCraftingObjectComponent::OnCraftingSuccess' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, CraftingObjectRepStateData) == 0x0000D0, "Member 'UCraftingObjectComponent::CraftingObjectRepStateData' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, CraftingFormulaRow) == 0x0000DC, "Member 'UCraftingObjectComponent::CraftingFormulaRow' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, NumToCraft) == 0x0000E0, "Member 'UCraftingObjectComponent::NumToCraft' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, CraftingInstigator) == 0x0000E4, "Member 'UCraftingObjectComponent::CraftingInstigator' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, AllOfTheIngredientItems) == 0x0000F0, "Member 'UCraftingObjectComponent::AllOfTheIngredientItems' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, NonConsumedIngredientItemIndices) == 0x000100, "Member 'UCraftingObjectComponent::NonConsumedIngredientItemIndices' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, LastIngredientStringForAnalytics) == 0x000110, "Member 'UCraftingObjectComponent::LastIngredientStringForAnalytics' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, LastFormulaStringForAnalytics) == 0x000120, "Member 'UCraftingObjectComponent::LastFormulaStringForAnalytics' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, LastResultsStringForAnalytics) == 0x000130, "Member 'UCraftingObjectComponent::LastResultsStringForAnalytics' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, CraftingResults) == 0x000140, "Member 'UCraftingObjectComponent::CraftingResults' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, WhileCraftingAbilitySpecHandle) == 0x000150, "Member 'UCraftingObjectComponent::WhileCraftingAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, OwnerCraftingAbilitySpecHandle) == 0x000154, "Member 'UCraftingObjectComponent::OwnerCraftingAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, CraftingObjectTag) == 0x000158, "Member 'UCraftingObjectComponent::CraftingObjectTag' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, CraftingObjectTags) == 0x000160, "Member 'UCraftingObjectComponent::CraftingObjectTags' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, CraftingTimeLength) == 0x000180, "Member 'UCraftingObjectComponent::CraftingTimeLength' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, ReadyTimeLength) == 0x0001A8, "Member 'UCraftingObjectComponent::ReadyTimeLength' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, OverCraftingTimeLength) == 0x0001D0, "Member 'UCraftingObjectComponent::OverCraftingTimeLength' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, ResettingTimeLength) == 0x0001F8, "Member 'UCraftingObjectComponent::ResettingTimeLength' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, OverCraftingLootTierKey) == 0x000220, "Member 'UCraftingObjectComponent::OverCraftingLootTierKey' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, IngredientSpawnOffset) == 0x000228, "Member 'UCraftingObjectComponent::IngredientSpawnOffset' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, OwnerCraftingAbility) == 0x000248, "Member 'UCraftingObjectComponent::OwnerCraftingAbility' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, WhileCraftingAbility) == 0x000270, "Member 'UCraftingObjectComponent::WhileCraftingAbility' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, CraftingFailedTags) == 0x000298, "Member 'UCraftingObjectComponent::CraftingFailedTags' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, PendingPickupCraftingItem) == 0x0002B8, "Member 'UCraftingObjectComponent::PendingPickupCraftingItem' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, PendingPickupCraftingFormula) == 0x0002C0, "Member 'UCraftingObjectComponent::PendingPickupCraftingFormula' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, PendingPickupCraftingItemEntry) == 0x0002C8, "Member 'UCraftingObjectComponent::PendingPickupCraftingItemEntry' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, PendingPickupHeldCount) == 0x000468, "Member 'UCraftingObjectComponent::PendingPickupHeldCount' has a wrong offset!");
static_assert(offsetof(UCraftingObjectComponent, FreeCraftingEnabled) == 0x000558, "Member 'UCraftingObjectComponent::FreeCraftingEnabled' has a wrong offset!");

// Class CraftingRuntime.FortControllerComponent_CraftingNetworkEvents
// 0x0010 (0x00B8 - 0x00A8)
class UFortControllerComponent_CraftingNetworkEvents final : public UFortControllerComponent
{
public:
	TMulticastInlineDelegate<void(class AFortPlayerController* Instigator, class AActor* CraftingObject, class FName& FormulaRowName)> OnCraftingSuccess;                                 // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ClientNotifyCraftingFailed(class AActor* CraftingObject, const struct FGameplayTagContainer& FailedReason);
	void ClientNotifyCraftingSuccess(class AActor* CraftingObject, const class FName& FormulaRowName);
	void NotifyCraftingSuccess(class AActor* CraftingObject, const class FName& FormulaRowName);
	void ServerCancelCrafting(class AActor* CraftingObject);
	void ServerClaimCraftingResults(class AActor* CraftingObject);
	void ServerEjectItems(class AActor* CraftingObject);
	void ServerPauseCrafting(class AActor* CraftingObject);
	void ServerPickupItemAndStartCrafting(class AActor* CraftingObject, class AFortPickup* PickUp, const class FName& CraftingFormulaName);
	void ServerReportCraftingSuccess(class AActor* CraftingObject);
	void ServerResumeCrafting(class AActor* CraftingObject);
	void ServerStartCrafting(class AActor* CraftingObject, const class FName& CraftingFormulaName, const int32 NumberToCraft);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortControllerComponent_CraftingNetworkEvents">();
	}
	static class UFortControllerComponent_CraftingNetworkEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortControllerComponent_CraftingNetworkEvents>();
	}
};
static_assert(alignof(UFortControllerComponent_CraftingNetworkEvents) == 0x000008, "Wrong alignment on UFortControllerComponent_CraftingNetworkEvents");
static_assert(sizeof(UFortControllerComponent_CraftingNetworkEvents) == 0x0000B8, "Wrong size on UFortControllerComponent_CraftingNetworkEvents");
static_assert(offsetof(UFortControllerComponent_CraftingNetworkEvents, OnCraftingSuccess) == 0x0000A8, "Member 'UFortControllerComponent_CraftingNetworkEvents::OnCraftingSuccess' has a wrong offset!");

// Class CraftingRuntime.FortGameStateComponent_Crafting
// 0x01A8 (0x0248 - 0x00A0)
class UFortGameStateComponent_Crafting final : public UFortGameStateComponent
{
public:
	struct FDataRegistryType                      CraftingFormulaRegistryType;                       // 0x00A0(0x0004)(ZeroConstructor, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataRegistryType                      CraftingIngredientsUIDataRegistryType;             // 0x00A4(0x0004)(ZeroConstructor, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x140];                                     // 0x00A8(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCraftingResult>                CraftingResultsList;                               // 0x01E8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8[0x50];                                     // 0x01F8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlaylistDataReady(class AFortGameStateAthena* GameState, const class UFortPlaylist* Playlist, const struct FGameplayTagContainer& PlaylistContextTags);
	void OnRep_CraftingResultsList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateComponent_Crafting">();
	}
	static class UFortGameStateComponent_Crafting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameStateComponent_Crafting>();
	}
};
static_assert(alignof(UFortGameStateComponent_Crafting) == 0x000008, "Wrong alignment on UFortGameStateComponent_Crafting");
static_assert(sizeof(UFortGameStateComponent_Crafting) == 0x000248, "Wrong size on UFortGameStateComponent_Crafting");
static_assert(offsetof(UFortGameStateComponent_Crafting, CraftingFormulaRegistryType) == 0x0000A0, "Member 'UFortGameStateComponent_Crafting::CraftingFormulaRegistryType' has a wrong offset!");
static_assert(offsetof(UFortGameStateComponent_Crafting, CraftingIngredientsUIDataRegistryType) == 0x0000A4, "Member 'UFortGameStateComponent_Crafting::CraftingIngredientsUIDataRegistryType' has a wrong offset!");
static_assert(offsetof(UFortGameStateComponent_Crafting, CraftingResultsList) == 0x0001E8, "Member 'UFortGameStateComponent_Crafting::CraftingResultsList' has a wrong offset!");

// Class CraftingRuntime.FortPickupInteractOverrideComponent_Crafting
// 0x0020 (0x00E0 - 0x00C0)
class UFortPickupInteractOverrideComponent_Crafting final : public UFortPickupInteractOverrideComponent
{
public:
	class UFortItemDefinition*                    LastPickupItemDef;                                 // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortItemDefinition*                    LastFocusedItemDef;                                // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastTargetFormulaName;                             // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ContextualCraftingInteractDuration;                // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETInteractionType                             CachedInteractionType;                             // 0x00D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionBeingAttempted                    CachedInteractionBeingAttempted;                   // 0x00D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPickupInteractOverrideComponent_Crafting">();
	}
	static class UFortPickupInteractOverrideComponent_Crafting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPickupInteractOverrideComponent_Crafting>();
	}
};
static_assert(alignof(UFortPickupInteractOverrideComponent_Crafting) == 0x000008, "Wrong alignment on UFortPickupInteractOverrideComponent_Crafting");
static_assert(sizeof(UFortPickupInteractOverrideComponent_Crafting) == 0x0000E0, "Wrong size on UFortPickupInteractOverrideComponent_Crafting");
static_assert(offsetof(UFortPickupInteractOverrideComponent_Crafting, LastPickupItemDef) == 0x0000C0, "Member 'UFortPickupInteractOverrideComponent_Crafting::LastPickupItemDef' has a wrong offset!");
static_assert(offsetof(UFortPickupInteractOverrideComponent_Crafting, LastFocusedItemDef) == 0x0000C8, "Member 'UFortPickupInteractOverrideComponent_Crafting::LastFocusedItemDef' has a wrong offset!");
static_assert(offsetof(UFortPickupInteractOverrideComponent_Crafting, LastTargetFormulaName) == 0x0000D0, "Member 'UFortPickupInteractOverrideComponent_Crafting::LastTargetFormulaName' has a wrong offset!");
static_assert(offsetof(UFortPickupInteractOverrideComponent_Crafting, ContextualCraftingInteractDuration) == 0x0000D4, "Member 'UFortPickupInteractOverrideComponent_Crafting::ContextualCraftingInteractDuration' has a wrong offset!");
static_assert(offsetof(UFortPickupInteractOverrideComponent_Crafting, CachedInteractionType) == 0x0000D8, "Member 'UFortPickupInteractOverrideComponent_Crafting::CachedInteractionType' has a wrong offset!");
static_assert(offsetof(UFortPickupInteractOverrideComponent_Crafting, CachedInteractionBeingAttempted) == 0x0000D9, "Member 'UFortPickupInteractOverrideComponent_Crafting::CachedInteractionBeingAttempted' has a wrong offset!");

// Class CraftingRuntime.FortContextualTutorial_CraftingComplete
// 0x0000 (0x00F8 - 0x00F8)
class UFortContextualTutorial_CraftingComplete final : public UFortContextualTutorial
{
public:
	void OnCraftingSuccess(class AFortPlayerController* Instigator, class AActor* CraftingObject, const class FName& FormulaRowName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortContextualTutorial_CraftingComplete">();
	}
	static class UFortContextualTutorial_CraftingComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortContextualTutorial_CraftingComplete>();
	}
};
static_assert(alignof(UFortContextualTutorial_CraftingComplete) == 0x000008, "Wrong alignment on UFortContextualTutorial_CraftingComplete");
static_assert(sizeof(UFortContextualTutorial_CraftingComplete) == 0x0000F8, "Wrong size on UFortContextualTutorial_CraftingComplete");

// Class CraftingRuntime.FortContextualTutorial_CraftingReady
// 0x0000 (0x00F8 - 0x00F8)
class UFortContextualTutorial_CraftingReady final : public UFortContextualTutorial
{
public:
	void HandleFormulaCraftableChanged(const class FName& FormulaRowName, bool bIsCraftable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortContextualTutorial_CraftingReady">();
	}
	static class UFortContextualTutorial_CraftingReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortContextualTutorial_CraftingReady>();
	}
};
static_assert(alignof(UFortContextualTutorial_CraftingReady) == 0x000008, "Wrong alignment on UFortContextualTutorial_CraftingReady");
static_assert(sizeof(UFortContextualTutorial_CraftingReady) == 0x0000F8, "Wrong size on UFortContextualTutorial_CraftingReady");

// Class CraftingRuntime.FortContextualTutorial_CraftingTabOpen
// 0x0008 (0x0100 - 0x00F8)
class UFortContextualTutorial_CraftingTabOpen final : public UFortContextualTutorial
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleFormulaCraftableChanged(const class FName& FormulaRowName, bool bIsCraftable);
	void HandleInventoryTabChanged(const class FName InventoryTabNameId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortContextualTutorial_CraftingTabOpen">();
	}
	static class UFortContextualTutorial_CraftingTabOpen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortContextualTutorial_CraftingTabOpen>();
	}
};
static_assert(alignof(UFortContextualTutorial_CraftingTabOpen) == 0x000008, "Wrong alignment on UFortContextualTutorial_CraftingTabOpen");
static_assert(sizeof(UFortContextualTutorial_CraftingTabOpen) == 0x000100, "Wrong size on UFortContextualTutorial_CraftingTabOpen");

// Class CraftingRuntime.CraftingLibrary
// 0x0000 (0x0028 - 0x0028)
class UCraftingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CancelCrafting(class AFortPlayerController* Instigator, class AActor* CraftingObject);
	static bool CanCraftFormula(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, const class FName CraftingFormulaRow, TArray<struct FCraftingIngredientQueryState>* OutIngredientStates, const int32 NumberToCraft);
	static bool CanCraftFormulaWithAdditionalItems(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, const class FName CraftingFormulaRow, const TArray<struct FItemAndCount>& AdditionalItems, TArray<struct FCraftingIngredientQueryState>* OutIngredientStates, const int32 NumberToCraft);
	static void ClaimCraftingResults(class AFortPlayerController* Instigator, class AActor* CraftingObject);
	static void EjectItems(class AFortPlayerController* Instigator, class AActor* CraftingObject);
	static void GetAllCraftableFormulas(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, TArray<class FName>* OutFormulas);
	static void GetAllCraftingFormulas(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, TArray<class FName>* OutFormulas);
	static void GetAllValidIngredients(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, TArray<struct FGameplayTagContainer>* OutIngredients);
	static TArray<class UFortWorldItem*> GetCraftedResults_TempItems(class AActor* CraftingObject);
	static bool GetCraftingFormulaIngredientRequirements(class UObject* WorldContextObject, const class FName& CraftingFormulaRow, TArray<struct FCraftingIngredientRequirement>* OutIngredientRequirements);
	static class FName GetCraftingFormulaNameBeingCrafted(class AActor* CraftingObject);
	static TArray<class UFortWorldItem*> GetCraftingIngredients_TempItems(class AActor* CraftingObject);
	static ECraftingObjectState GetCraftingObjectCraftingState(class AActor* CraftingObject);
	static float GetCraftingObjectCurrentCraftingStateEndTime(const class AActor* CraftingObject);
	static float GetCraftingObjectCurrentCraftingStateStartTime(const class AActor* CraftingObject);
	static float GetCraftingObjectCurrentCraftingStateTimeLeft(const class AActor* CraftingObject);
	static void GetCraftingResultsForRowName(const class UObject* WorldContextObject, const class FName& CraftingFormulaRow, TArray<struct FItemAndCount>* OutResults, int32 NumToCraft);
	static TArray<class UFortWorldItem*> GetIngredientsInCraftingObject(class AActor* CraftingObject);
	static void GetKnownCraftingFormulas(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, TArray<class FName>* OutFormulas);
	static void GetUIDataForCraftingIngredientTags(class UObject* WorldContextObject, const struct FGameplayTagContainer& IngredientTags, TArray<TSoftObjectPtr<class UFortItemDefinition>>* OutItemDefs, TArray<TSoftObjectPtr<class UObject>>* OutIcons);
	static void GetValidIngredientsInInventory(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, TArray<class UFortWorldItem*>* OutIngredients);
	static void GiveItemToCraftingObject(class AFortPlayerController* Instigator, class AActor* CraftingObject, const struct FFortItemEntry& ItemEntryToGrant);
	static bool IsValidIngredient(const class AFortPlayerController* FortPC, const class AActor* CraftingObject, const class UFortItemDefinition* ItemDef);
	static void PauseCrafting(class AFortPlayerController* Instigator, class AActor* CraftingObject);
	static void PickupItemAndStartCrafting(class AFortPlayerController* Instigator, class AActor* CraftingObject, class AFortPickup* PickUp, const class FName& CraftingFormulaName);
	static void ReportCraftingSuccess(class AFortPlayerController* Instigator, class AActor* CraftingObject);
	static void ResumeCrafting(class AFortPlayerController* Instigator, class AActor* CraftingObject);
	static void StartCrafting(class AFortPlayerController* Instigator, class AActor* CraftingObject, const class FName& CraftingFormulaName, const int32 NumberToCraft);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CraftingLibrary">();
	}
	static class UCraftingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCraftingLibrary>();
	}
};
static_assert(alignof(UCraftingLibrary) == 0x000008, "Wrong alignment on UCraftingLibrary");
static_assert(sizeof(UCraftingLibrary) == 0x000028, "Wrong size on UCraftingLibrary");

}

