#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MotionTrajectory

#include "Basic.hpp"

#include "MotionTrajectory_classes.hpp"
#include "MotionTrajectory_parameters.hpp"


namespace SDK
{

// Function MotionTrajectory.MotionTrajectoryComponent.SetSampleRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionTrajectoryComponent::SetSampleRate(int32 Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTrajectoryComponent", "SetSampleRate");

	Params::MotionTrajectoryComponent_SetSampleRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionTrajectory.MotionTrajectoryComponent.GetHistory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryComponent::GetHistory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTrajectoryComponent", "GetHistory");

	Params::MotionTrajectoryComponent_GetHistory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryComponent.GetTrajectory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryComponent::GetTrajectory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTrajectoryComponent", "GetTrajectory");

	Params::MotionTrajectoryComponent_GetTrajectory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryComponent.GetTrajectoryWithSettings
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMotionTrajectorySettings        Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bIncludeHistory                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryComponent::GetTrajectoryWithSettings(const struct FMotionTrajectorySettings& Settings, bool bIncludeHistory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTrajectoryComponent", "GetTrajectoryWithSettings");

	Params::MotionTrajectoryComponent_GetTrajectoryWithSettings Parms{};

	Parms.Settings = std::move(Settings);
	Parms.bIncludeHistory = bIncludeHistory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.CharacterMovementTrajectoryComponent.OnMovementUpdated
// (Final, Native, Protected, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementTrajectoryComponent::OnMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementTrajectoryComponent", "OnMovementUpdated");

	Params::CharacterMovementTrajectoryComponent_OnMovementUpdated Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.ClampTrajectoryDirection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTrajectorySampleRange           Trajectory                                             (Parm, NativeAccessSpecifierPublic)
// TArray<struct FTrajectoryDirectionClamp>Directions                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bPreserveRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryBlueprintLibrary::ClampTrajectoryDirection(const struct FTrajectorySampleRange& Trajectory, const TArray<struct FTrajectoryDirectionClamp>& Directions, bool bPreserveRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "ClampTrajectoryDirection");

	Params::MotionTrajectoryBlueprintLibrary_ClampTrajectoryDirection Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.Directions = std::move(Directions);
	Parms.bPreserveRotation = bPreserveRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.DebugDrawTrajectory
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       WorldTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLinearColor                     PredictionColor                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     HistoryColor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TransformScale                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TransformThickness                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowScale                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowThickness                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionTrajectoryBlueprintLibrary::DebugDrawTrajectory(const class AActor* Actor, const struct FTransform& WorldTransform, const struct FTrajectorySampleRange& Trajectory, const struct FLinearColor& PredictionColor, const struct FLinearColor& HistoryColor, float TransformScale, float TransformThickness, float ArrowScale, float ArrowSize, float ArrowThickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "DebugDrawTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_DebugDrawTrajectory Parms{};

	Parms.Actor = Actor;
	Parms.WorldTransform = std::move(WorldTransform);
	Parms.Trajectory = std::move(Trajectory);
	Parms.PredictionColor = std::move(PredictionColor);
	Parms.HistoryColor = std::move(HistoryColor);
	Parms.TransformScale = TransformScale;
	Parms.TransformThickness = TransformThickness;
	Parms.ArrowScale = ArrowScale;
	Parms.ArrowSize = ArrowSize;
	Parms.ArrowThickness = ArrowThickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.FlattenTrajectory2D
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTrajectorySampleRange           Trajectory                                             (Parm, NativeAccessSpecifierPublic)
// bool                                    PreserveSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryBlueprintLibrary::FlattenTrajectory2D(const struct FTrajectorySampleRange& Trajectory, bool PreserveSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "FlattenTrajectory2D");

	Params::MotionTrajectoryBlueprintLibrary_FlattenTrajectory2D Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.PreserveSpeed = PreserveSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.IsConstantSpeedTrajectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTrajectorySampleRange           Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::IsConstantSpeedTrajectory(const struct FTrajectorySampleRange& Trajectory, float Speed, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "IsConstantSpeedTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_IsConstantSpeedTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.Speed = Speed;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.IsSharpVelocityDirChange
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTrajectorySampleRange           Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MinSharpTurnAngleDegrees                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrajectorySampleDomain                 RotationConstraintDomain                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotationConstraintValue                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAlignmentAngleDegrees                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinLinearSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TurnAxis                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ForwardAxis                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::IsSharpVelocityDirChange(const struct FTrajectorySampleRange& Trajectory, float MinSharpTurnAngleDegrees, ETrajectorySampleDomain RotationConstraintDomain, float RotationConstraintValue, float MaxAlignmentAngleDegrees, float MinLinearSpeed, const struct FVector& TurnAxis, const struct FVector& ForwardAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "IsSharpVelocityDirChange");

	Params::MotionTrajectoryBlueprintLibrary_IsSharpVelocityDirChange Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.MinSharpTurnAngleDegrees = MinSharpTurnAngleDegrees;
	Parms.RotationConstraintDomain = RotationConstraintDomain;
	Parms.RotationConstraintValue = RotationConstraintValue;
	Parms.MaxAlignmentAngleDegrees = MaxAlignmentAngleDegrees;
	Parms.MinLinearSpeed = MinLinearSpeed;
	Parms.TurnAxis = std::move(TurnAxis);
	Parms.ForwardAxis = std::move(ForwardAxis);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.IsStartingTrajectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTrajectorySampleRange           Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MoveMinSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdleMaxSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::IsStartingTrajectory(const struct FTrajectorySampleRange& Trajectory, float MoveMinSpeed, float IdleMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "IsStartingTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_IsStartingTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.MoveMinSpeed = MoveMinSpeed;
	Parms.IdleMaxSpeed = IdleMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.IsStoppingTrajectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTrajectorySampleRange           Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MoveMinSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdleMaxSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::IsStoppingTrajectory(const struct FTrajectorySampleRange& Trajectory, float MoveMinSpeed, float IdleMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "IsStoppingTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_IsStoppingTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.MoveMinSpeed = MoveMinSpeed;
	Parms.IdleMaxSpeed = IdleMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.MakeTrajectoryRelativeToComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTrajectorySampleRange           ActorTrajectory                                        (Parm, NativeAccessSpecifierPublic)
// class USceneComponent*                  Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryBlueprintLibrary::MakeTrajectoryRelativeToComponent(const struct FTrajectorySampleRange& ActorTrajectory, const class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "MakeTrajectoryRelativeToComponent");

	Params::MotionTrajectoryBlueprintLibrary_MakeTrajectoryRelativeToComponent Parms{};

	Parms.ActorTrajectory = std::move(ActorTrajectory);
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.RotateTrajectory
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTrajectorySampleRange           Trajectory                                             (Parm, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryBlueprintLibrary::RotateTrajectory(const struct FTrajectorySampleRange& Trajectory, const struct FQuat& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "RotateTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_RotateTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

