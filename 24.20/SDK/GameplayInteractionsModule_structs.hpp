#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayInteractionsModule

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "StateTreeModule_structs.hpp"
#include "SmartObjectsModule_structs.hpp"
#include "StructUtils_structs.hpp"


namespace SDK
{

// Enum GameplayInteractionsModule.EGameplayTaskActuationResult
// NumValues: 0x0005
enum class EGameplayTaskActuationResult : uint8
{
	None                                     = 0,
	RequestFailed                            = 1,
	Failed                                   = 2,
	Succeeded                                = 3,
	EGameplayTaskActuationResult_MAX         = 4,
};

// Enum GameplayInteractionsModule.EGameplayTransitionResult
// NumValues: 0x0004
enum class EGameplayTransitionResult : uint8
{
	Cancelled                                = 0,
	Succeeded                                = 1,
	Failed                                   = 2,
	EGameplayTransitionResult_MAX            = 3,
};

// Enum GameplayInteractionsModule.EGameplayInteractionAbortReason
// NumValues: 0x0004
enum class EGameplayInteractionAbortReason : uint8
{
	Unset                                    = 0,
	ExternalAbort                            = 1,
	InternalAbort                            = 2,
	EGameplayInteractionAbortReason_MAX      = 3,
};

// Enum GameplayInteractionsModule.EGameplayInteractionModifyGameplayTagOperation
// NumValues: 0x0003
enum class EGameplayInteractionModifyGameplayTagOperation : uint8
{
	Add                                      = 0,
	Remove                                   = 1,
	EGameplayInteractionModifyGameplayTagOperation_MAX = 2,
};

// Enum GameplayInteractionsModule.EGameplayInteractionTaskModify
// NumValues: 0x0006
enum class EGameplayInteractionTaskModify : uint8
{
	OnEnterStateUndoOnExitState              = 0,
	OnEnterState                             = 1,
	OnExitState                              = 2,
	OnExitStateFailed                        = 3,
	OnExitStateSucceeded                     = 4,
	EGameplayInteractionTaskModify_MAX       = 5,
};

// Enum GameplayInteractionsModule.EGameplayInteractionTaskTrigger
// NumValues: 0x0005
enum class EGameplayInteractionTaskTrigger : uint8
{
	OnEnterState                             = 0,
	OnExitState                              = 1,
	OnExitStateSucceeded                     = 2,
	OnExitStateFailed                        = 3,
	EGameplayInteractionTaskTrigger_MAX      = 4,
};

// Enum GameplayInteractionsModule.EGameplayTaskMoveToIntent
// NumValues: 0x0003
enum class EGameplayTaskMoveToIntent : uint8
{
	Stop                                     = 0,
	KeepMoving                               = 1,
	EGameplayTaskMoveToIntent_MAX            = 2,
};

// Enum GameplayInteractionsModule.EPlayContextualAnimExitMode
// NumValues: 0x0004
enum class EPlayContextualAnimExitMode : uint8
{
	DefaultExit                              = 0,
	FastExit                                 = 1,
	Teleport                                 = 2,
	EPlayContextualAnimExitMode_MAX          = 3,
};

// Enum GameplayInteractionsModule.EPlayContextualAnimStatus
// NumValues: 0x0005
enum class EPlayContextualAnimStatus : uint8
{
	Unset                                    = 0,
	Playing                                  = 1,
	DonePlaying                              = 2,
	Failed                                   = 3,
	EPlayContextualAnimStatus_MAX            = 4,
};

// Enum GameplayInteractionsModule.EGameplayInteractionMatchSlotTagSource
// NumValues: 0x0003
enum class EGameplayInteractionMatchSlotTagSource : uint8
{
	ActivityTags                             = 0,
	RuntimeTags                              = 1,
	EGameplayInteractionMatchSlotTagSource_MAX = 2,
};

// Enum GameplayInteractionsModule.EGameplayInteractionSlotReferenceType
// NumValues: 0x0003
enum class EGameplayInteractionSlotReferenceType : uint8
{
	ByActivityTag                            = 0,
	ByLinkTag                                = 1,
	EGameplayInteractionSlotReferenceType_MAX = 2,
};

// Enum GameplayInteractionsModule.EGameplayInteractionSyncSlotTransitionState
// NumValues: 0x0004
enum class EGameplayInteractionSyncSlotTransitionState : uint8
{
	WaitingForFromTag                        = 0,
	WaitingForToTag                          = 1,
	Completed                                = 2,
	EGameplayInteractionSyncSlotTransitionState_MAX = 3,
};

// ScriptStruct GameplayInteractionsModule.GameplayActuationStateBase
// 0x0028 (0x0028 - 0x0000)
struct FGameplayActuationStateBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActuationName;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavigationLocation;                                // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayActuationStateBase) == 0x000008, "Wrong alignment on FGameplayActuationStateBase");
static_assert(sizeof(FGameplayActuationStateBase) == 0x000028, "Wrong size on FGameplayActuationStateBase");
static_assert(offsetof(FGameplayActuationStateBase, ActuationName) == 0x000008, "Member 'FGameplayActuationStateBase::ActuationName' has a wrong offset!");
static_assert(offsetof(FGameplayActuationStateBase, NavigationLocation) == 0x000010, "Member 'FGameplayActuationStateBase::NavigationLocation' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayActuationPredictedLocation
// 0x0030 (0x0030 - 0x0000)
struct FGameplayActuationPredictedLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              Direction;                                         // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayActuationPredictedLocation) == 0x000008, "Wrong alignment on FGameplayActuationPredictedLocation");
static_assert(sizeof(FGameplayActuationPredictedLocation) == 0x000030, "Wrong size on FGameplayActuationPredictedLocation");
static_assert(offsetof(FGameplayActuationPredictedLocation, Location) == 0x000000, "Member 'FGameplayActuationPredictedLocation::Location' has a wrong offset!");
static_assert(offsetof(FGameplayActuationPredictedLocation, Direction) == 0x000018, "Member 'FGameplayActuationPredictedLocation::Direction' has a wrong offset!");
static_assert(offsetof(FGameplayActuationPredictedLocation, Time) == 0x000024, "Member 'FGameplayActuationPredictedLocation::Time' has a wrong offset!");
static_assert(offsetof(FGameplayActuationPredictedLocation, Speed) == 0x000028, "Member 'FGameplayActuationPredictedLocation::Speed' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayActuationState_Moving
// 0x0060 (0x0088 - 0x0028)
struct FGameplayActuationState_Moving : public FGameplayActuationStateBase
{
public:
	struct FVector3f                              HeadingDirection;                                  // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayActuationPredictedLocation    Prediction;                                        // 0x0038(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x20];                                      // 0x0068(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayActuationState_Moving) == 0x000008, "Wrong alignment on FGameplayActuationState_Moving");
static_assert(sizeof(FGameplayActuationState_Moving) == 0x000088, "Wrong size on FGameplayActuationState_Moving");
static_assert(offsetof(FGameplayActuationState_Moving, HeadingDirection) == 0x000028, "Member 'FGameplayActuationState_Moving::HeadingDirection' has a wrong offset!");
static_assert(offsetof(FGameplayActuationState_Moving, Prediction) == 0x000038, "Member 'FGameplayActuationState_Moving::Prediction' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayActuationState_Standing
// 0x0000 (0x0088 - 0x0088)
struct FGameplayActuationState_Standing final : public FGameplayActuationState_Moving
{
};
static_assert(alignof(FGameplayActuationState_Standing) == 0x000008, "Wrong alignment on FGameplayActuationState_Standing");
static_assert(sizeof(FGameplayActuationState_Standing) == 0x000088, "Wrong size on FGameplayActuationState_Standing");

// ScriptStruct GameplayInteractionsModule.GameplayActuationState_MovingTransition
// 0x0000 (0x0088 - 0x0088)
struct FGameplayActuationState_MovingTransition final : public FGameplayActuationState_Moving
{
};
static_assert(alignof(FGameplayActuationState_MovingTransition) == 0x000008, "Wrong alignment on FGameplayActuationState_MovingTransition");
static_assert(sizeof(FGameplayActuationState_MovingTransition) == 0x000088, "Wrong size on FGameplayActuationState_MovingTransition");

// ScriptStruct GameplayInteractionsModule.GameplayTransitionDesc
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGameplayTransitionDesc
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTransitionDesc) == 0x000008, "Wrong alignment on FGameplayTransitionDesc");
static_assert(sizeof(FGameplayTransitionDesc) == 0x000008, "Wrong size on FGameplayTransitionDesc");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionAbortContext
// 0x0001 (0x0001 - 0x0000)
struct FGameplayInteractionAbortContext final
{
public:
	EGameplayInteractionAbortReason               Reason;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayInteractionAbortContext) == 0x000001, "Wrong alignment on FGameplayInteractionAbortContext");
static_assert(sizeof(FGameplayInteractionAbortContext) == 0x000001, "Wrong size on FGameplayInteractionAbortContext");
static_assert(offsetof(FGameplayInteractionAbortContext, Reason) == 0x000000, "Member 'FGameplayInteractionAbortContext::Reason' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionContext
// 0x0048 (0x0048 - 0x0000)
struct FGameplayInteractionContext final
{
public:
	struct FStateTreeInstanceData                 StateTreeInstanceData;                             // 0x0000(0x0010)(Protected, NativeAccessSpecifierProtected)
	struct FSmartObjectClaimHandle                ClaimedHandle;                                     // 0x0010(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayInteractionAbortContext       AbortContext;                                      // 0x0028(0x0001)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ContextActor;                                      // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 SmartObjectActor;                                  // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayInteractionSmartObjectBehaviorDefinition* Definition;                                        // 0x0040(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayInteractionContext) == 0x000008, "Wrong alignment on FGameplayInteractionContext");
static_assert(sizeof(FGameplayInteractionContext) == 0x000048, "Wrong size on FGameplayInteractionContext");
static_assert(offsetof(FGameplayInteractionContext, StateTreeInstanceData) == 0x000000, "Member 'FGameplayInteractionContext::StateTreeInstanceData' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionContext, ClaimedHandle) == 0x000010, "Member 'FGameplayInteractionContext::ClaimedHandle' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionContext, AbortContext) == 0x000028, "Member 'FGameplayInteractionContext::AbortContext' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionContext, ContextActor) == 0x000030, "Member 'FGameplayInteractionContext::ContextActor' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionContext, SmartObjectActor) == 0x000038, "Member 'FGameplayInteractionContext::SmartObjectActor' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionContext, Definition) == 0x000040, "Member 'FGameplayInteractionContext::Definition' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionSlotUserData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FGameplayInteractionSlotUserData final : public FSmartObjectSlotStateData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionSlotUserData) == 0x000004, "Wrong alignment on FGameplayInteractionSlotUserData");
static_assert(sizeof(FGameplayInteractionSlotUserData) == 0x000008, "Wrong size on FGameplayInteractionSlotUserData");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionStateTreeTask
// 0x0000 (0x0020 - 0x0020)
struct FGameplayInteractionStateTreeTask : public FStateTreeTaskBase
{
};
static_assert(alignof(FGameplayInteractionStateTreeTask) == 0x000008, "Wrong alignment on FGameplayInteractionStateTreeTask");
static_assert(sizeof(FGameplayInteractionStateTreeTask) == 0x000020, "Wrong size on FGameplayInteractionStateTreeTask");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionStateTreeCondition
// 0x0000 (0x0020 - 0x0020)
struct FGameplayInteractionStateTreeCondition : public FStateTreeConditionBase
{
};
static_assert(alignof(FGameplayInteractionStateTreeCondition) == 0x000008, "Wrong alignment on FGameplayInteractionStateTreeCondition");
static_assert(sizeof(FGameplayInteractionStateTreeCondition) == 0x000020, "Wrong size on FGameplayInteractionStateTreeCondition");

// ScriptStruct GameplayInteractionsModule.GameplayTransitionDesc_MoveToStand
// 0x0000 (0x0008 - 0x0008)
struct FGameplayTransitionDesc_MoveToStand final : public FGameplayTransitionDesc
{
};
static_assert(alignof(FGameplayTransitionDesc_MoveToStand) == 0x000008, "Wrong alignment on FGameplayTransitionDesc_MoveToStand");
static_assert(sizeof(FGameplayTransitionDesc_MoveToStand) == 0x000008, "Wrong size on FGameplayTransitionDesc_MoveToStand");

// ScriptStruct GameplayInteractionsModule.GameplayActuationState_ContextualAnim
// 0x0030 (0x0058 - 0x0028)
struct FGameplayActuationState_ContextualAnim final : public FGameplayActuationStateBase
{
public:
	class FName                                   InteractorRole;                                    // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InteractableObject;                                // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractableObjectRole;                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SectionName;                                       // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExitSectionName;                                   // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UContextualAnimSceneAsset*              SceneAsset;                                        // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UContextualAnimSceneInstance*           SceneInstance;                                     // 0x0050(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayActuationState_ContextualAnim) == 0x000008, "Wrong alignment on FGameplayActuationState_ContextualAnim");
static_assert(sizeof(FGameplayActuationState_ContextualAnim) == 0x000058, "Wrong size on FGameplayActuationState_ContextualAnim");
static_assert(offsetof(FGameplayActuationState_ContextualAnim, InteractorRole) == 0x000028, "Member 'FGameplayActuationState_ContextualAnim::InteractorRole' has a wrong offset!");
static_assert(offsetof(FGameplayActuationState_ContextualAnim, InteractableObject) == 0x000030, "Member 'FGameplayActuationState_ContextualAnim::InteractableObject' has a wrong offset!");
static_assert(offsetof(FGameplayActuationState_ContextualAnim, InteractableObjectRole) == 0x000038, "Member 'FGameplayActuationState_ContextualAnim::InteractableObjectRole' has a wrong offset!");
static_assert(offsetof(FGameplayActuationState_ContextualAnim, SectionName) == 0x00003C, "Member 'FGameplayActuationState_ContextualAnim::SectionName' has a wrong offset!");
static_assert(offsetof(FGameplayActuationState_ContextualAnim, ExitSectionName) == 0x000040, "Member 'FGameplayActuationState_ContextualAnim::ExitSectionName' has a wrong offset!");
static_assert(offsetof(FGameplayActuationState_ContextualAnim, SceneAsset) == 0x000048, "Member 'FGameplayActuationState_ContextualAnim::SceneAsset' has a wrong offset!");
static_assert(offsetof(FGameplayActuationState_ContextualAnim, SceneInstance) == 0x000050, "Member 'FGameplayActuationState_ContextualAnim::SceneInstance' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayTransitionDesc_EnterContextualAnim
// 0x0000 (0x0008 - 0x0008)
struct FGameplayTransitionDesc_EnterContextualAnim final : public FGameplayTransitionDesc
{
};
static_assert(alignof(FGameplayTransitionDesc_EnterContextualAnim) == 0x000008, "Wrong alignment on FGameplayTransitionDesc_EnterContextualAnim");
static_assert(sizeof(FGameplayTransitionDesc_EnterContextualAnim) == 0x000008, "Wrong size on FGameplayTransitionDesc_EnterContextualAnim");

// ScriptStruct GameplayInteractionsModule.GameplayTransitionDesc_ExitContextualAnim
// 0x0000 (0x0008 - 0x0008)
struct FGameplayTransitionDesc_ExitContextualAnim final : public FGameplayTransitionDesc
{
};
static_assert(alignof(FGameplayTransitionDesc_ExitContextualAnim) == 0x000008, "Wrong alignment on FGameplayTransitionDesc_ExitContextualAnim");
static_assert(sizeof(FGameplayTransitionDesc_ExitContextualAnim) == 0x000008, "Wrong size on FGameplayTransitionDesc_ExitContextualAnim");

// ScriptStruct GameplayInteractionsModule.GameplayTransitionDesc_StandToMove
// 0x0000 (0x0008 - 0x0008)
struct FGameplayTransitionDesc_StandToMove final : public FGameplayTransitionDesc
{
};
static_assert(alignof(FGameplayTransitionDesc_StandToMove) == 0x000008, "Wrong alignment on FGameplayTransitionDesc_StandToMove");
static_assert(sizeof(FGameplayTransitionDesc_StandToMove) == 0x000008, "Wrong size on FGameplayTransitionDesc_StandToMove");

// ScriptStruct GameplayInteractionsModule.GameplayTransitionDesc_SuddenTurn
// 0x0000 (0x0008 - 0x0008)
struct FGameplayTransitionDesc_SuddenTurn final : public FGameplayTransitionDesc
{
};
static_assert(alignof(FGameplayTransitionDesc_SuddenTurn) == 0x000008, "Wrong alignment on FGameplayTransitionDesc_SuddenTurn");
static_assert(sizeof(FGameplayTransitionDesc_SuddenTurn) == 0x000008, "Wrong size on FGameplayTransitionDesc_SuddenTurn");

// ScriptStruct GameplayInteractionsModule.ContextualAnimStateTreeTaskInstanceData
// 0x0038 (0x0038 - 0x0000)
struct FContextualAnimStateTreeTaskInstanceData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UContextualAnimSceneAsset*              ContextualAnimAsset;                               // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InteractableObject;                                // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_PlayContextualAnim*       Task;                                              // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractorRole;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractableObjectRole;                            // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayInteractionAbortContext       AbortContext;                                      // 0x0030(0x0001)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextualAnimStateTreeTaskInstanceData) == 0x000008, "Wrong alignment on FContextualAnimStateTreeTaskInstanceData");
static_assert(sizeof(FContextualAnimStateTreeTaskInstanceData) == 0x000038, "Wrong size on FContextualAnimStateTreeTaskInstanceData");
static_assert(offsetof(FContextualAnimStateTreeTaskInstanceData, Actor) == 0x000000, "Member 'FContextualAnimStateTreeTaskInstanceData::Actor' has a wrong offset!");
static_assert(offsetof(FContextualAnimStateTreeTaskInstanceData, ContextualAnimAsset) == 0x000008, "Member 'FContextualAnimStateTreeTaskInstanceData::ContextualAnimAsset' has a wrong offset!");
static_assert(offsetof(FContextualAnimStateTreeTaskInstanceData, InteractableObject) == 0x000010, "Member 'FContextualAnimStateTreeTaskInstanceData::InteractableObject' has a wrong offset!");
static_assert(offsetof(FContextualAnimStateTreeTaskInstanceData, Task) == 0x000018, "Member 'FContextualAnimStateTreeTaskInstanceData::Task' has a wrong offset!");
static_assert(offsetof(FContextualAnimStateTreeTaskInstanceData, Duration) == 0x000020, "Member 'FContextualAnimStateTreeTaskInstanceData::Duration' has a wrong offset!");
static_assert(offsetof(FContextualAnimStateTreeTaskInstanceData, Time) == 0x000024, "Member 'FContextualAnimStateTreeTaskInstanceData::Time' has a wrong offset!");
static_assert(offsetof(FContextualAnimStateTreeTaskInstanceData, InteractorRole) == 0x000028, "Member 'FContextualAnimStateTreeTaskInstanceData::InteractorRole' has a wrong offset!");
static_assert(offsetof(FContextualAnimStateTreeTaskInstanceData, InteractableObjectRole) == 0x00002C, "Member 'FContextualAnimStateTreeTaskInstanceData::InteractableObjectRole' has a wrong offset!");
static_assert(offsetof(FContextualAnimStateTreeTaskInstanceData, AbortContext) == 0x000030, "Member 'FContextualAnimStateTreeTaskInstanceData::AbortContext' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.ContextualAnimStateTreeTask
// 0x0010 (0x0030 - 0x0020)
struct FContextualAnimStateTreeTask final : public FGameplayInteractionStateTreeTask
{
public:
	class FName                                   Section;                                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ExitSection;                                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextualAnimStateTreeTask) == 0x000008, "Wrong alignment on FContextualAnimStateTreeTask");
static_assert(sizeof(FContextualAnimStateTreeTask) == 0x000030, "Wrong size on FContextualAnimStateTreeTask");
static_assert(offsetof(FContextualAnimStateTreeTask, Section) == 0x000020, "Member 'FContextualAnimStateTreeTask::Section' has a wrong offset!");
static_assert(offsetof(FContextualAnimStateTreeTask, ExitSection) == 0x000024, "Member 'FContextualAnimStateTreeTask::ExitSection' has a wrong offset!");
static_assert(offsetof(FContextualAnimStateTreeTask, bEnabled) == 0x000028, "Member 'FContextualAnimStateTreeTask::bEnabled' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionMatchSlotTagsConditionInstanceData
// 0x0028 (0x0028 - 0x0000)
struct FGameplayInteractionMatchSlotTagsConditionInstanceData final
{
public:
	struct FSmartObjectSlotHandle                 Slot;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsToMatch;                                       // 0x0008(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayInteractionMatchSlotTagsConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayInteractionMatchSlotTagsConditionInstanceData");
static_assert(sizeof(FGameplayInteractionMatchSlotTagsConditionInstanceData) == 0x000028, "Wrong size on FGameplayInteractionMatchSlotTagsConditionInstanceData");
static_assert(offsetof(FGameplayInteractionMatchSlotTagsConditionInstanceData, Slot) == 0x000000, "Member 'FGameplayInteractionMatchSlotTagsConditionInstanceData::Slot' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionMatchSlotTagsConditionInstanceData, TagsToMatch) == 0x000008, "Member 'FGameplayInteractionMatchSlotTagsConditionInstanceData::TagsToMatch' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionSlotTagsMatchCondition
// 0x0008 (0x0028 - 0x0020)
struct FGameplayInteractionSlotTagsMatchCondition final : public FGameplayInteractionStateTreeCondition
{
public:
	EGameplayInteractionMatchSlotTagSource        Source;                                            // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayContainerMatchType                   MatchType;                                         // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExactMatch;                                       // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0023(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionSlotTagsMatchCondition) == 0x000008, "Wrong alignment on FGameplayInteractionSlotTagsMatchCondition");
static_assert(sizeof(FGameplayInteractionSlotTagsMatchCondition) == 0x000028, "Wrong size on FGameplayInteractionSlotTagsMatchCondition");
static_assert(offsetof(FGameplayInteractionSlotTagsMatchCondition, Source) == 0x000020, "Member 'FGameplayInteractionSlotTagsMatchCondition::Source' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionSlotTagsMatchCondition, MatchType) == 0x000021, "Member 'FGameplayInteractionSlotTagsMatchCondition::MatchType' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionSlotTagsMatchCondition, bExactMatch) == 0x000022, "Member 'FGameplayInteractionSlotTagsMatchCondition::bExactMatch' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionSlotTagsMatchCondition, bInvert) == 0x000023, "Member 'FGameplayInteractionSlotTagsMatchCondition::bInvert' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionQuerySlotTagsConditionInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FGameplayInteractionQuerySlotTagsConditionInstanceData final
{
public:
	struct FSmartObjectSlotHandle                 Slot;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayInteractionQuerySlotTagsConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayInteractionQuerySlotTagsConditionInstanceData");
static_assert(sizeof(FGameplayInteractionQuerySlotTagsConditionInstanceData) == 0x000008, "Wrong size on FGameplayInteractionQuerySlotTagsConditionInstanceData");
static_assert(offsetof(FGameplayInteractionQuerySlotTagsConditionInstanceData, Slot) == 0x000000, "Member 'FGameplayInteractionQuerySlotTagsConditionInstanceData::Slot' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionQuerySlotTagCondition
// 0x0058 (0x0078 - 0x0020)
struct FGameplayInteractionQuerySlotTagCondition final : public FGameplayInteractionStateTreeCondition
{
public:
	EGameplayInteractionMatchSlotTagSource        Source;                                            // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      TagQuery;                                          // 0x0028(0x0048)(Edit, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionQuerySlotTagCondition) == 0x000008, "Wrong alignment on FGameplayInteractionQuerySlotTagCondition");
static_assert(sizeof(FGameplayInteractionQuerySlotTagCondition) == 0x000078, "Wrong size on FGameplayInteractionQuerySlotTagCondition");
static_assert(offsetof(FGameplayInteractionQuerySlotTagCondition, Source) == 0x000020, "Member 'FGameplayInteractionQuerySlotTagCondition::Source' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionQuerySlotTagCondition, TagQuery) == 0x000028, "Member 'FGameplayInteractionQuerySlotTagCondition::TagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionQuerySlotTagCondition, bInvert) == 0x000070, "Member 'FGameplayInteractionQuerySlotTagCondition::bInvert' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionIsSlotHandleValidConditionInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FGameplayInteractionIsSlotHandleValidConditionInstanceData final
{
public:
	struct FSmartObjectSlotHandle                 Slot;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayInteractionIsSlotHandleValidConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayInteractionIsSlotHandleValidConditionInstanceData");
static_assert(sizeof(FGameplayInteractionIsSlotHandleValidConditionInstanceData) == 0x000008, "Wrong size on FGameplayInteractionIsSlotHandleValidConditionInstanceData");
static_assert(offsetof(FGameplayInteractionIsSlotHandleValidConditionInstanceData, Slot) == 0x000000, "Member 'FGameplayInteractionIsSlotHandleValidConditionInstanceData::Slot' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionIsSlotHandleValidCondition
// 0x0008 (0x0028 - 0x0020)
struct FGameplayInteractionIsSlotHandleValidCondition final : public FGameplayInteractionStateTreeCondition
{
public:
	bool                                          bInvert;                                           // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionIsSlotHandleValidCondition) == 0x000008, "Wrong alignment on FGameplayInteractionIsSlotHandleValidCondition");
static_assert(sizeof(FGameplayInteractionIsSlotHandleValidCondition) == 0x000028, "Wrong size on FGameplayInteractionIsSlotHandleValidCondition");
static_assert(offsetof(FGameplayInteractionIsSlotHandleValidCondition, bInvert) == 0x000020, "Member 'FGameplayInteractionIsSlotHandleValidCondition::bInvert' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionFindSlotTaskInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FGameplayInteractionFindSlotTaskInstanceData final
{
public:
	struct FSmartObjectSlotHandle                 ReferenceSlot;                                     // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSmartObjectSlotHandle                 ResultSlot;                                        // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayInteractionFindSlotTaskInstanceData) == 0x000008, "Wrong alignment on FGameplayInteractionFindSlotTaskInstanceData");
static_assert(sizeof(FGameplayInteractionFindSlotTaskInstanceData) == 0x000010, "Wrong size on FGameplayInteractionFindSlotTaskInstanceData");
static_assert(offsetof(FGameplayInteractionFindSlotTaskInstanceData, ReferenceSlot) == 0x000000, "Member 'FGameplayInteractionFindSlotTaskInstanceData::ReferenceSlot' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionFindSlotTaskInstanceData, ResultSlot) == 0x000008, "Member 'FGameplayInteractionFindSlotTaskInstanceData::ResultSlot' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionFindSlotTask
// 0x0010 (0x0030 - 0x0020)
struct FGameplayInteractionFindSlotTask final : public FGameplayInteractionStateTreeTask
{
public:
	EGameplayInteractionSlotReferenceType         ReferenceType;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           FindByTag;                                         // 0x0024(0x0004)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionFindSlotTask) == 0x000008, "Wrong alignment on FGameplayInteractionFindSlotTask");
static_assert(sizeof(FGameplayInteractionFindSlotTask) == 0x000030, "Wrong size on FGameplayInteractionFindSlotTask");
static_assert(offsetof(FGameplayInteractionFindSlotTask, ReferenceType) == 0x000020, "Member 'FGameplayInteractionFindSlotTask::ReferenceType' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionFindSlotTask, FindByTag) == 0x000024, "Member 'FGameplayInteractionFindSlotTask::FindByTag' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionGetSlotActorTaskInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FGameplayInteractionGetSlotActorTaskInstanceData final
{
public:
	struct FSmartObjectSlotHandle                 TargetSlot;                                        // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ResultActor;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayInteractionGetSlotActorTaskInstanceData) == 0x000008, "Wrong alignment on FGameplayInteractionGetSlotActorTaskInstanceData");
static_assert(sizeof(FGameplayInteractionGetSlotActorTaskInstanceData) == 0x000010, "Wrong size on FGameplayInteractionGetSlotActorTaskInstanceData");
static_assert(offsetof(FGameplayInteractionGetSlotActorTaskInstanceData, TargetSlot) == 0x000000, "Member 'FGameplayInteractionGetSlotActorTaskInstanceData::TargetSlot' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionGetSlotActorTaskInstanceData, ResultActor) == 0x000008, "Member 'FGameplayInteractionGetSlotActorTaskInstanceData::ResultActor' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionGetSlotActorTask
// 0x0008 (0x0028 - 0x0020)
struct FGameplayInteractionGetSlotActorTask final : public FGameplayInteractionStateTreeTask
{
public:
	bool                                          bFailIfNotFound;                                   // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionGetSlotActorTask) == 0x000008, "Wrong alignment on FGameplayInteractionGetSlotActorTask");
static_assert(sizeof(FGameplayInteractionGetSlotActorTask) == 0x000028, "Wrong size on FGameplayInteractionGetSlotActorTask");
static_assert(offsetof(FGameplayInteractionGetSlotActorTask, bFailIfNotFound) == 0x000020, "Member 'FGameplayInteractionGetSlotActorTask::bFailIfNotFound' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionListenSlotEventsTaskInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FGameplayInteractionListenSlotEventsTaskInstanceData final
{
public:
	struct FSmartObjectSlotHandle                 TargetSlot;                                        // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionListenSlotEventsTaskInstanceData) == 0x000008, "Wrong alignment on FGameplayInteractionListenSlotEventsTaskInstanceData");
static_assert(sizeof(FGameplayInteractionListenSlotEventsTaskInstanceData) == 0x000010, "Wrong size on FGameplayInteractionListenSlotEventsTaskInstanceData");
static_assert(offsetof(FGameplayInteractionListenSlotEventsTaskInstanceData, TargetSlot) == 0x000000, "Member 'FGameplayInteractionListenSlotEventsTaskInstanceData::TargetSlot' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionListenSlotEventsTask
// 0x0008 (0x0028 - 0x0020)
struct FGameplayInteractionListenSlotEventsTask final : public FGameplayInteractionStateTreeTask
{
public:
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionListenSlotEventsTask) == 0x000008, "Wrong alignment on FGameplayInteractionListenSlotEventsTask");
static_assert(sizeof(FGameplayInteractionListenSlotEventsTask) == 0x000028, "Wrong size on FGameplayInteractionListenSlotEventsTask");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionModifySlotTagTaskInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FGameplayInteractionModifySlotTagTaskInstanceData final
{
public:
	struct FSmartObjectSlotHandle                 TargetSlot;                                        // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTagRemoved;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionModifySlotTagTaskInstanceData) == 0x000008, "Wrong alignment on FGameplayInteractionModifySlotTagTaskInstanceData");
static_assert(sizeof(FGameplayInteractionModifySlotTagTaskInstanceData) == 0x000010, "Wrong size on FGameplayInteractionModifySlotTagTaskInstanceData");
static_assert(offsetof(FGameplayInteractionModifySlotTagTaskInstanceData, TargetSlot) == 0x000000, "Member 'FGameplayInteractionModifySlotTagTaskInstanceData::TargetSlot' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionModifySlotTagTaskInstanceData, bTagRemoved) == 0x000008, "Member 'FGameplayInteractionModifySlotTagTaskInstanceData::bTagRemoved' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionModifySlotTagTask
// 0x0010 (0x0030 - 0x0020)
struct FGameplayInteractionModifySlotTagTask final : public FGameplayInteractionStateTreeTask
{
public:
	EGameplayInteractionTaskModify                Modify;                                            // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayInteractionModifyGameplayTagOperation Operation;                                         // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           tag;                                               // 0x0024(0x0004)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionModifySlotTagTask) == 0x000008, "Wrong alignment on FGameplayInteractionModifySlotTagTask");
static_assert(sizeof(FGameplayInteractionModifySlotTagTask) == 0x000030, "Wrong size on FGameplayInteractionModifySlotTagTask");
static_assert(offsetof(FGameplayInteractionModifySlotTagTask, Modify) == 0x000020, "Member 'FGameplayInteractionModifySlotTagTask::Modify' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionModifySlotTagTask, Operation) == 0x000021, "Member 'FGameplayInteractionModifySlotTagTask::Operation' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionModifySlotTagTask, tag) == 0x000024, "Member 'FGameplayInteractionModifySlotTagTask::tag' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionSendSlotEventTaskInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FGameplayInteractionSendSlotEventTaskInstanceData final
{
public:
	struct FSmartObjectSlotHandle                 TargetSlot;                                        // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayInteractionSendSlotEventTaskInstanceData) == 0x000008, "Wrong alignment on FGameplayInteractionSendSlotEventTaskInstanceData");
static_assert(sizeof(FGameplayInteractionSendSlotEventTaskInstanceData) == 0x000008, "Wrong size on FGameplayInteractionSendSlotEventTaskInstanceData");
static_assert(offsetof(FGameplayInteractionSendSlotEventTaskInstanceData, TargetSlot) == 0x000000, "Member 'FGameplayInteractionSendSlotEventTaskInstanceData::TargetSlot' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionSendSlotEventTask
// 0x0020 (0x0040 - 0x0020)
struct FGameplayInteractionSendSlotEventTask final : public FGameplayInteractionStateTreeTask
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0020(0x0004)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInstancedStruct                       Payload;                                           // 0x0028(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	EGameplayInteractionTaskTrigger               Trigger;                                           // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldTriggerOnReselect;                          // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionSendSlotEventTask) == 0x000008, "Wrong alignment on FGameplayInteractionSendSlotEventTask");
static_assert(sizeof(FGameplayInteractionSendSlotEventTask) == 0x000040, "Wrong size on FGameplayInteractionSendSlotEventTask");
static_assert(offsetof(FGameplayInteractionSendSlotEventTask, EventTag) == 0x000020, "Member 'FGameplayInteractionSendSlotEventTask::EventTag' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionSendSlotEventTask, Payload) == 0x000028, "Member 'FGameplayInteractionSendSlotEventTask::Payload' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionSendSlotEventTask, Trigger) == 0x000038, "Member 'FGameplayInteractionSendSlotEventTask::Trigger' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionSendSlotEventTask, bShouldTriggerOnReselect) == 0x000039, "Member 'FGameplayInteractionSendSlotEventTask::bShouldTriggerOnReselect' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionSetSlotEnabledInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FGameplayInteractionSetSlotEnabledInstanceData final
{
public:
	struct FSmartObjectSlotHandle                 TargetSlot;                                        // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialState;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionSetSlotEnabledInstanceData) == 0x000008, "Wrong alignment on FGameplayInteractionSetSlotEnabledInstanceData");
static_assert(sizeof(FGameplayInteractionSetSlotEnabledInstanceData) == 0x000010, "Wrong size on FGameplayInteractionSetSlotEnabledInstanceData");
static_assert(offsetof(FGameplayInteractionSetSlotEnabledInstanceData, TargetSlot) == 0x000000, "Member 'FGameplayInteractionSetSlotEnabledInstanceData::TargetSlot' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionSetSlotEnabledInstanceData, bInitialState) == 0x000008, "Member 'FGameplayInteractionSetSlotEnabledInstanceData::bInitialState' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionSetSlotEnabledTask
// 0x0008 (0x0028 - 0x0020)
struct FGameplayInteractionSetSlotEnabledTask final : public FGameplayInteractionStateTreeTask
{
public:
	EGameplayInteractionTaskModify                Modify;                                            // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableSlot;                                       // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionSetSlotEnabledTask) == 0x000008, "Wrong alignment on FGameplayInteractionSetSlotEnabledTask");
static_assert(sizeof(FGameplayInteractionSetSlotEnabledTask) == 0x000028, "Wrong size on FGameplayInteractionSetSlotEnabledTask");
static_assert(offsetof(FGameplayInteractionSetSlotEnabledTask, Modify) == 0x000020, "Member 'FGameplayInteractionSetSlotEnabledTask::Modify' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionSetSlotEnabledTask, bEnableSlot) == 0x000021, "Member 'FGameplayInteractionSetSlotEnabledTask::bEnableSlot' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionSyncSlotTagStateInstanceData
// 0x0018 (0x0018 - 0x0000)
struct FGameplayInteractionSyncSlotTagStateInstanceData final
{
public:
	struct FSmartObjectSlotHandle                 TargetSlot;                                        // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionSyncSlotTagStateInstanceData) == 0x000008, "Wrong alignment on FGameplayInteractionSyncSlotTagStateInstanceData");
static_assert(sizeof(FGameplayInteractionSyncSlotTagStateInstanceData) == 0x000018, "Wrong size on FGameplayInteractionSyncSlotTagStateInstanceData");
static_assert(offsetof(FGameplayInteractionSyncSlotTagStateInstanceData, TargetSlot) == 0x000000, "Member 'FGameplayInteractionSyncSlotTagStateInstanceData::TargetSlot' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionSyncSlotTagStateTask
// 0x0010 (0x0030 - 0x0020)
struct FGameplayInteractionSyncSlotTagStateTask final : public FGameplayInteractionStateTreeTask
{
public:
	struct FGameplayTag                           TagToMonitor;                                      // 0x0020(0x0004)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           BreakEventTag;                                     // 0x0024(0x0004)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionSyncSlotTagStateTask) == 0x000008, "Wrong alignment on FGameplayInteractionSyncSlotTagStateTask");
static_assert(sizeof(FGameplayInteractionSyncSlotTagStateTask) == 0x000030, "Wrong size on FGameplayInteractionSyncSlotTagStateTask");
static_assert(offsetof(FGameplayInteractionSyncSlotTagStateTask, TagToMonitor) == 0x000020, "Member 'FGameplayInteractionSyncSlotTagStateTask::TagToMonitor' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionSyncSlotTagStateTask, BreakEventTag) == 0x000024, "Member 'FGameplayInteractionSyncSlotTagStateTask::BreakEventTag' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionSyncSlotTagTransitionInstanceData
// 0x0018 (0x0018 - 0x0000)
struct FGameplayInteractionSyncSlotTagTransitionInstanceData final
{
public:
	struct FSmartObjectSlotHandle                 TargetSlot;                                        // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionSyncSlotTagTransitionInstanceData) == 0x000008, "Wrong alignment on FGameplayInteractionSyncSlotTagTransitionInstanceData");
static_assert(sizeof(FGameplayInteractionSyncSlotTagTransitionInstanceData) == 0x000018, "Wrong size on FGameplayInteractionSyncSlotTagTransitionInstanceData");
static_assert(offsetof(FGameplayInteractionSyncSlotTagTransitionInstanceData, TargetSlot) == 0x000000, "Member 'FGameplayInteractionSyncSlotTagTransitionInstanceData::TargetSlot' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.GameplayInteractionSyncSlotTagTransitionTask
// 0x0010 (0x0030 - 0x0020)
struct FGameplayInteractionSyncSlotTagTransitionTask final : public FGameplayInteractionStateTreeTask
{
public:
	struct FGameplayTag                           TransitionFromTag;                                 // 0x0020(0x0004)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TransitionToTag;                                   // 0x0024(0x0004)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TransitionEventTag;                                // 0x0028(0x0004)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayInteractionSyncSlotTagTransitionTask) == 0x000008, "Wrong alignment on FGameplayInteractionSyncSlotTagTransitionTask");
static_assert(sizeof(FGameplayInteractionSyncSlotTagTransitionTask) == 0x000030, "Wrong size on FGameplayInteractionSyncSlotTagTransitionTask");
static_assert(offsetof(FGameplayInteractionSyncSlotTagTransitionTask, TransitionFromTag) == 0x000020, "Member 'FGameplayInteractionSyncSlotTagTransitionTask::TransitionFromTag' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionSyncSlotTagTransitionTask, TransitionToTag) == 0x000024, "Member 'FGameplayInteractionSyncSlotTagTransitionTask::TransitionToTag' has a wrong offset!");
static_assert(offsetof(FGameplayInteractionSyncSlotTagTransitionTask, TransitionEventTag) == 0x000028, "Member 'FGameplayInteractionSyncSlotTagTransitionTask::TransitionEventTag' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.PlayMontageStateTreeTaskInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FPlayMontageStateTreeTaskInstanceData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ComputedDuration;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayMontageStateTreeTaskInstanceData) == 0x000008, "Wrong alignment on FPlayMontageStateTreeTaskInstanceData");
static_assert(sizeof(FPlayMontageStateTreeTaskInstanceData) == 0x000010, "Wrong size on FPlayMontageStateTreeTaskInstanceData");
static_assert(offsetof(FPlayMontageStateTreeTaskInstanceData, Actor) == 0x000000, "Member 'FPlayMontageStateTreeTaskInstanceData::Actor' has a wrong offset!");
static_assert(offsetof(FPlayMontageStateTreeTaskInstanceData, ComputedDuration) == 0x000008, "Member 'FPlayMontageStateTreeTaskInstanceData::ComputedDuration' has a wrong offset!");
static_assert(offsetof(FPlayMontageStateTreeTaskInstanceData, Time) == 0x00000C, "Member 'FPlayMontageStateTreeTaskInstanceData::Time' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.PlayMontageStateTreeTask
// 0x0008 (0x0028 - 0x0020)
struct FPlayMontageStateTreeTask final : public FGameplayInteractionStateTreeTask
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPlayMontageStateTreeTask) == 0x000008, "Wrong alignment on FPlayMontageStateTreeTask");
static_assert(sizeof(FPlayMontageStateTreeTask) == 0x000028, "Wrong size on FPlayMontageStateTreeTask");
static_assert(offsetof(FPlayMontageStateTreeTask, Montage) == 0x000020, "Member 'FPlayMontageStateTreeTask::Montage' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.StateTreeTask_FindSlotEntryForActor_InstanceData
// 0x0080 (0x0080 - 0x0000)
struct FStateTreeTask_FindSlotEntryForActor_InstanceData final
{
public:
	class AActor*                                 UserActor;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSmartObjectSlotHandle                 ReferenceSlot;                                     // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             EntryTransform;                                    // 0x0010(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EntryTag;                                          // 0x0070(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTask_FindSlotEntryForActor_InstanceData) == 0x000010, "Wrong alignment on FStateTreeTask_FindSlotEntryForActor_InstanceData");
static_assert(sizeof(FStateTreeTask_FindSlotEntryForActor_InstanceData) == 0x000080, "Wrong size on FStateTreeTask_FindSlotEntryForActor_InstanceData");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor_InstanceData, UserActor) == 0x000000, "Member 'FStateTreeTask_FindSlotEntryForActor_InstanceData::UserActor' has a wrong offset!");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor_InstanceData, ReferenceSlot) == 0x000008, "Member 'FStateTreeTask_FindSlotEntryForActor_InstanceData::ReferenceSlot' has a wrong offset!");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor_InstanceData, EntryTransform) == 0x000010, "Member 'FStateTreeTask_FindSlotEntryForActor_InstanceData::EntryTransform' has a wrong offset!");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor_InstanceData, EntryTag) == 0x000070, "Member 'FStateTreeTask_FindSlotEntryForActor_InstanceData::EntryTag' has a wrong offset!");

// ScriptStruct GameplayInteractionsModule.StateTreeTask_FindSlotEntryForActor
// 0x0030 (0x0050 - 0x0020)
struct FStateTreeTask_FindSlotEntryForActor final : public FGameplayInteractionStateTreeTask
{
public:
	EFSmartObjectSlotEntrySelectionMethod         SelectMethod;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireResultInNavigableSpace;                    // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSlotLocationAsFallbackCandidate;               // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIncludeEntriesAsCandidates;                       // 0x0023(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIncludeExistsAsCandidates;                        // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     NavigationFilter;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector3f                              NavigationValidationExtents;                       // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator3f                             ResultRotationAdjustment;                          // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTask_FindSlotEntryForActor) == 0x000008, "Wrong alignment on FStateTreeTask_FindSlotEntryForActor");
static_assert(sizeof(FStateTreeTask_FindSlotEntryForActor) == 0x000050, "Wrong size on FStateTreeTask_FindSlotEntryForActor");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor, SelectMethod) == 0x000020, "Member 'FStateTreeTask_FindSlotEntryForActor::SelectMethod' has a wrong offset!");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor, bRequireResultInNavigableSpace) == 0x000021, "Member 'FStateTreeTask_FindSlotEntryForActor::bRequireResultInNavigableSpace' has a wrong offset!");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor, bUseSlotLocationAsFallbackCandidate) == 0x000022, "Member 'FStateTreeTask_FindSlotEntryForActor::bUseSlotLocationAsFallbackCandidate' has a wrong offset!");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor, bIncludeEntriesAsCandidates) == 0x000023, "Member 'FStateTreeTask_FindSlotEntryForActor::bIncludeEntriesAsCandidates' has a wrong offset!");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor, bIncludeExistsAsCandidates) == 0x000024, "Member 'FStateTreeTask_FindSlotEntryForActor::bIncludeExistsAsCandidates' has a wrong offset!");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor, NavigationFilter) == 0x000028, "Member 'FStateTreeTask_FindSlotEntryForActor::NavigationFilter' has a wrong offset!");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor, NavigationValidationExtents) == 0x000030, "Member 'FStateTreeTask_FindSlotEntryForActor::NavigationValidationExtents' has a wrong offset!");
static_assert(offsetof(FStateTreeTask_FindSlotEntryForActor, ResultRotationAdjustment) == 0x00003C, "Member 'FStateTreeTask_FindSlotEntryForActor::ResultRotationAdjustment' has a wrong offset!");

}

