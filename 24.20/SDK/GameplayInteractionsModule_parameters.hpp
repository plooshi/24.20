#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayInteractionsModule

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "SmartObjectsModule_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayInteractionsModule_structs.hpp"


namespace SDK::Params
{

// Function GameplayInteractionsModule.AITask_UseGameplayInteraction.UseClaimedGameplayInteractionSmartObject
// 0x0030 (0x0030 - 0x0000)
struct AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject final
{
public:
	class AAIController*                          Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSmartObjectClaimHandle                ClaimHandle;                                       // 0x0008(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLockAILogic;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAITask_UseGameplayInteraction*         ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject) == 0x000008, "Wrong alignment on AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject");
static_assert(sizeof(AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject) == 0x000030, "Wrong size on AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject");
static_assert(offsetof(AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject, Controller) == 0x000000, "Member 'AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject::Controller' has a wrong offset!");
static_assert(offsetof(AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject, ClaimHandle) == 0x000008, "Member 'AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject::ClaimHandle' has a wrong offset!");
static_assert(offsetof(AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject, bLockAILogic) == 0x000020, "Member 'AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject::bLockAILogic' has a wrong offset!");
static_assert(offsetof(AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject, ReturnValue) == 0x000028, "Member 'AITask_UseGameplayInteraction_UseClaimedGameplayInteractionSmartObject::ReturnValue' has a wrong offset!");

// Function GameplayInteractionsModule.GameplayTask_MoveTo.MoveTo
// 0x0040 (0x0040 - 0x0000)
struct GameplayTask_MoveTo_MoveTo final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GoalLocation;                                      // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 GoalActor;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayTaskMoveToIntent                     EndOfPathIntent;                                   // 0x0028(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AcceptanceRadius;                                  // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIOptionFlag                                 StopOnOverlap;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIOptionFlag                                 AcceptPartialPath;                                 // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePathfinding;                                   // 0x0032(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseContinuousGoalTracking;                        // 0x0033(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIOptionFlag                                 ProjectGoalOnNavigation;                           // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTask_MoveTo*                   ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_MoveTo_MoveTo) == 0x000008, "Wrong alignment on GameplayTask_MoveTo_MoveTo");
static_assert(sizeof(GameplayTask_MoveTo_MoveTo) == 0x000040, "Wrong size on GameplayTask_MoveTo_MoveTo");
static_assert(offsetof(GameplayTask_MoveTo_MoveTo, Actor) == 0x000000, "Member 'GameplayTask_MoveTo_MoveTo::Actor' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveTo_MoveTo, GoalLocation) == 0x000008, "Member 'GameplayTask_MoveTo_MoveTo::GoalLocation' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveTo_MoveTo, GoalActor) == 0x000020, "Member 'GameplayTask_MoveTo_MoveTo::GoalActor' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveTo_MoveTo, EndOfPathIntent) == 0x000028, "Member 'GameplayTask_MoveTo_MoveTo::EndOfPathIntent' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveTo_MoveTo, AcceptanceRadius) == 0x00002C, "Member 'GameplayTask_MoveTo_MoveTo::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveTo_MoveTo, StopOnOverlap) == 0x000030, "Member 'GameplayTask_MoveTo_MoveTo::StopOnOverlap' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveTo_MoveTo, AcceptPartialPath) == 0x000031, "Member 'GameplayTask_MoveTo_MoveTo::AcceptPartialPath' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveTo_MoveTo, bUsePathfinding) == 0x000032, "Member 'GameplayTask_MoveTo_MoveTo::bUsePathfinding' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveTo_MoveTo, bUseContinuousGoalTracking) == 0x000033, "Member 'GameplayTask_MoveTo_MoveTo::bUseContinuousGoalTracking' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveTo_MoveTo, ProjectGoalOnNavigation) == 0x000034, "Member 'GameplayTask_MoveTo_MoveTo::ProjectGoalOnNavigation' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveTo_MoveTo, ReturnValue) == 0x000038, "Member 'GameplayTask_MoveTo_MoveTo::ReturnValue' has a wrong offset!");

// Function GameplayInteractionsModule.GameplayTask_MoveToContextualAnim.EnterContextualAnim
// 0x0038 (0x0038 - 0x0000)
struct GameplayTask_MoveToContextualAnim_EnterContextualAnim final
{
public:
	class AActor*                                 Interactor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractorRole;                                    // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InteractableObject;                                // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractableObjectRole;                            // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SectionName;                                       // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExitSectionName;                                   // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UContextualAnimSceneAsset*        SceneAsset;                                        // 0x0028(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_MoveToContextualAnim*     ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_MoveToContextualAnim_EnterContextualAnim) == 0x000008, "Wrong alignment on GameplayTask_MoveToContextualAnim_EnterContextualAnim");
static_assert(sizeof(GameplayTask_MoveToContextualAnim_EnterContextualAnim) == 0x000038, "Wrong size on GameplayTask_MoveToContextualAnim_EnterContextualAnim");
static_assert(offsetof(GameplayTask_MoveToContextualAnim_EnterContextualAnim, Interactor) == 0x000000, "Member 'GameplayTask_MoveToContextualAnim_EnterContextualAnim::Interactor' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveToContextualAnim_EnterContextualAnim, InteractorRole) == 0x000008, "Member 'GameplayTask_MoveToContextualAnim_EnterContextualAnim::InteractorRole' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveToContextualAnim_EnterContextualAnim, InteractableObject) == 0x000010, "Member 'GameplayTask_MoveToContextualAnim_EnterContextualAnim::InteractableObject' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveToContextualAnim_EnterContextualAnim, InteractableObjectRole) == 0x000018, "Member 'GameplayTask_MoveToContextualAnim_EnterContextualAnim::InteractableObjectRole' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveToContextualAnim_EnterContextualAnim, SectionName) == 0x00001C, "Member 'GameplayTask_MoveToContextualAnim_EnterContextualAnim::SectionName' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveToContextualAnim_EnterContextualAnim, ExitSectionName) == 0x000020, "Member 'GameplayTask_MoveToContextualAnim_EnterContextualAnim::ExitSectionName' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveToContextualAnim_EnterContextualAnim, SceneAsset) == 0x000028, "Member 'GameplayTask_MoveToContextualAnim_EnterContextualAnim::SceneAsset' has a wrong offset!");
static_assert(offsetof(GameplayTask_MoveToContextualAnim_EnterContextualAnim, ReturnValue) == 0x000030, "Member 'GameplayTask_MoveToContextualAnim_EnterContextualAnim::ReturnValue' has a wrong offset!");

// Function GameplayInteractionsModule.GameplayTask_PlayContextualAnim.PlayContextualAnim
// 0x0038 (0x0038 - 0x0000)
struct GameplayTask_PlayContextualAnim_PlayContextualAnim final
{
public:
	class AActor*                                 Interactor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractorRole_0;                                  // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InteractableObject_0;                              // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractableObjectRole_0;                          // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SectionName;                                       // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExitSectionName_0;                                 // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UContextualAnimSceneAsset*        SceneAsset_0;                                      // 0x0028(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_PlayContextualAnim*       ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_PlayContextualAnim_PlayContextualAnim) == 0x000008, "Wrong alignment on GameplayTask_PlayContextualAnim_PlayContextualAnim");
static_assert(sizeof(GameplayTask_PlayContextualAnim_PlayContextualAnim) == 0x000038, "Wrong size on GameplayTask_PlayContextualAnim_PlayContextualAnim");
static_assert(offsetof(GameplayTask_PlayContextualAnim_PlayContextualAnim, Interactor) == 0x000000, "Member 'GameplayTask_PlayContextualAnim_PlayContextualAnim::Interactor' has a wrong offset!");
static_assert(offsetof(GameplayTask_PlayContextualAnim_PlayContextualAnim, InteractorRole_0) == 0x000008, "Member 'GameplayTask_PlayContextualAnim_PlayContextualAnim::InteractorRole_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_PlayContextualAnim_PlayContextualAnim, InteractableObject_0) == 0x000010, "Member 'GameplayTask_PlayContextualAnim_PlayContextualAnim::InteractableObject_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_PlayContextualAnim_PlayContextualAnim, InteractableObjectRole_0) == 0x000018, "Member 'GameplayTask_PlayContextualAnim_PlayContextualAnim::InteractableObjectRole_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_PlayContextualAnim_PlayContextualAnim, SectionName) == 0x00001C, "Member 'GameplayTask_PlayContextualAnim_PlayContextualAnim::SectionName' has a wrong offset!");
static_assert(offsetof(GameplayTask_PlayContextualAnim_PlayContextualAnim, ExitSectionName_0) == 0x000020, "Member 'GameplayTask_PlayContextualAnim_PlayContextualAnim::ExitSectionName_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_PlayContextualAnim_PlayContextualAnim, SceneAsset_0) == 0x000028, "Member 'GameplayTask_PlayContextualAnim_PlayContextualAnim::SceneAsset_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_PlayContextualAnim_PlayContextualAnim, ReturnValue) == 0x000030, "Member 'GameplayTask_PlayContextualAnim_PlayContextualAnim::ReturnValue' has a wrong offset!");

// Function GameplayInteractionsModule.GameplayTask_PlayContextualAnim.OnSectionEndTimeReached
// 0x0008 (0x0008 - 0x0000)
struct GameplayTask_PlayContextualAnim_OnSectionEndTimeReached final
{
public:
	class UContextualAnimSceneInstance*           SceneInstance_0;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_PlayContextualAnim_OnSectionEndTimeReached) == 0x000008, "Wrong alignment on GameplayTask_PlayContextualAnim_OnSectionEndTimeReached");
static_assert(sizeof(GameplayTask_PlayContextualAnim_OnSectionEndTimeReached) == 0x000008, "Wrong size on GameplayTask_PlayContextualAnim_OnSectionEndTimeReached");
static_assert(offsetof(GameplayTask_PlayContextualAnim_OnSectionEndTimeReached, SceneInstance_0) == 0x000000, "Member 'GameplayTask_PlayContextualAnim_OnSectionEndTimeReached::SceneInstance_0' has a wrong offset!");

// Function GameplayInteractionsModule.GameplayTask_PlayContextualAnim.SetExit
// 0x0008 (0x0008 - 0x0000)
struct GameplayTask_PlayContextualAnim_SetExit final
{
public:
	EPlayContextualAnimExitMode                   ExitMode;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NewExitSectionName;                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_PlayContextualAnim_SetExit) == 0x000004, "Wrong alignment on GameplayTask_PlayContextualAnim_SetExit");
static_assert(sizeof(GameplayTask_PlayContextualAnim_SetExit) == 0x000008, "Wrong size on GameplayTask_PlayContextualAnim_SetExit");
static_assert(offsetof(GameplayTask_PlayContextualAnim_SetExit, ExitMode) == 0x000000, "Member 'GameplayTask_PlayContextualAnim_SetExit::ExitMode' has a wrong offset!");
static_assert(offsetof(GameplayTask_PlayContextualAnim_SetExit, NewExitSectionName) == 0x000004, "Member 'GameplayTask_PlayContextualAnim_SetExit::NewExitSectionName' has a wrong offset!");

// Function GameplayInteractionsModule.GameplayTask_PlayContextualAnim.GetStatus
// 0x0001 (0x0001 - 0x0000)
struct GameplayTask_PlayContextualAnim_GetStatus final
{
public:
	EPlayContextualAnimStatus                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_PlayContextualAnim_GetStatus) == 0x000001, "Wrong alignment on GameplayTask_PlayContextualAnim_GetStatus");
static_assert(sizeof(GameplayTask_PlayContextualAnim_GetStatus) == 0x000001, "Wrong size on GameplayTask_PlayContextualAnim_GetStatus");
static_assert(offsetof(GameplayTask_PlayContextualAnim_GetStatus, ReturnValue) == 0x000000, "Member 'GameplayTask_PlayContextualAnim_GetStatus::ReturnValue' has a wrong offset!");

// Function GameplayInteractionsModule.GameplayTask_StandAt.StandAt
// 0x0018 (0x0018 - 0x0000)
struct GameplayTask_StandAt_StandAt final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTask_StandAt*                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_StandAt_StandAt) == 0x000008, "Wrong alignment on GameplayTask_StandAt_StandAt");
static_assert(sizeof(GameplayTask_StandAt_StandAt) == 0x000018, "Wrong size on GameplayTask_StandAt_StandAt");
static_assert(offsetof(GameplayTask_StandAt_StandAt, Pawn) == 0x000000, "Member 'GameplayTask_StandAt_StandAt::Pawn' has a wrong offset!");
static_assert(offsetof(GameplayTask_StandAt_StandAt, Duration) == 0x000008, "Member 'GameplayTask_StandAt_StandAt::Duration' has a wrong offset!");
static_assert(offsetof(GameplayTask_StandAt_StandAt, ReturnValue) == 0x000010, "Member 'GameplayTask_StandAt_StandAt::ReturnValue' has a wrong offset!");

}

