#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayInteractionsModule

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "StateTreeModule_structs.hpp"
#include "StateTreeModule_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "SmartObjectsModule_structs.hpp"
#include "SmartObjectsModule_classes.hpp"
#include "GameplayInteractionsModule_structs.hpp"
#include "GameplayTasks_classes.hpp"
#include "StructUtils_structs.hpp"
#include "ContextualAnimation_structs.hpp"


namespace SDK
{

// Class GameplayInteractionsModule.GameplayActuationStateProvider
// 0x0000 (0x0028 - 0x0028)
class IGameplayActuationStateProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayActuationStateProvider">();
	}
	static class IGameplayActuationStateProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameplayActuationStateProvider>();
	}
};
static_assert(alignof(IGameplayActuationStateProvider) == 0x000008, "Wrong alignment on IGameplayActuationStateProvider");
static_assert(sizeof(IGameplayActuationStateProvider) == 0x000028, "Wrong size on IGameplayActuationStateProvider");

// Class GameplayInteractionsModule.GameplayInteractionSmartObjectBehaviorDefinition
// 0x0018 (0x0040 - 0x0028)
class UGameplayInteractionSmartObjectBehaviorDefinition : public USmartObjectBehaviorDefinition
{
public:
	struct FStateTreeReference                    StateTreeReference;                                // 0x0028(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayInteractionSmartObjectBehaviorDefinition">();
	}
	static class UGameplayInteractionSmartObjectBehaviorDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayInteractionSmartObjectBehaviorDefinition>();
	}
};
static_assert(alignof(UGameplayInteractionSmartObjectBehaviorDefinition) == 0x000008, "Wrong alignment on UGameplayInteractionSmartObjectBehaviorDefinition");
static_assert(sizeof(UGameplayInteractionSmartObjectBehaviorDefinition) == 0x000040, "Wrong size on UGameplayInteractionSmartObjectBehaviorDefinition");
static_assert(offsetof(UGameplayInteractionSmartObjectBehaviorDefinition, StateTreeReference) == 0x000028, "Member 'UGameplayInteractionSmartObjectBehaviorDefinition::StateTreeReference' has a wrong offset!");

// Class GameplayInteractionsModule.GameplayTaskTransition
// 0x0000 (0x0028 - 0x0028)
class IGameplayTaskTransition final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTaskTransition">();
	}
	static class IGameplayTaskTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameplayTaskTransition>();
	}
};
static_assert(alignof(IGameplayTaskTransition) == 0x000008, "Wrong alignment on IGameplayTaskTransition");
static_assert(sizeof(IGameplayTaskTransition) == 0x000028, "Wrong size on IGameplayTaskTransition");

// Class GameplayInteractionsModule.AITask_UseGameplayInteraction
// 0x0078 (0x00E0 - 0x0068)
class UAITask_UseGameplayInteraction final : public UAITask
{
public:
	TMulticastInlineDelegate<void()>              OnFinished;                                        // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FGameplayInteractionContext            GameplayInteractionContext;                        // 0x0078(0x0048)(Protected, NativeAccessSpecifierProtected)
	struct FSmartObjectClaimHandle                ClaimedHandle;                                     // 0x00C0(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayInteractionAbortContext       AbortContext;                                      // 0x00D8(0x0001)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAITask_UseGameplayInteraction* UseClaimedGameplayInteractionSmartObject(class AAIController* Controller, const struct FSmartObjectClaimHandle& ClaimHandle, bool bLockAILogic);

	void RequestAbort();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITask_UseGameplayInteraction">();
	}
	static class UAITask_UseGameplayInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITask_UseGameplayInteraction>();
	}
};
static_assert(alignof(UAITask_UseGameplayInteraction) == 0x000008, "Wrong alignment on UAITask_UseGameplayInteraction");
static_assert(sizeof(UAITask_UseGameplayInteraction) == 0x0000E0, "Wrong size on UAITask_UseGameplayInteraction");
static_assert(offsetof(UAITask_UseGameplayInteraction, OnFinished) == 0x000068, "Member 'UAITask_UseGameplayInteraction::OnFinished' has a wrong offset!");
static_assert(offsetof(UAITask_UseGameplayInteraction, GameplayInteractionContext) == 0x000078, "Member 'UAITask_UseGameplayInteraction::GameplayInteractionContext' has a wrong offset!");
static_assert(offsetof(UAITask_UseGameplayInteraction, ClaimedHandle) == 0x0000C0, "Member 'UAITask_UseGameplayInteraction::ClaimedHandle' has a wrong offset!");
static_assert(offsetof(UAITask_UseGameplayInteraction, AbortContext) == 0x0000D8, "Member 'UAITask_UseGameplayInteraction::AbortContext' has a wrong offset!");

// Class GameplayInteractionsModule.GameplayActuationComponent
// 0x0038 (0x00D8 - 0x00A0)
class UGameplayActuationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInstancedStruct                       ActuationState;                                    // 0x00A8(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInstancedStruct>               Transitions;                                       // 0x00C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnableTransitions;                                // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayActuationComponent">();
	}
	static class UGameplayActuationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayActuationComponent>();
	}
};
static_assert(alignof(UGameplayActuationComponent) == 0x000008, "Wrong alignment on UGameplayActuationComponent");
static_assert(sizeof(UGameplayActuationComponent) == 0x0000D8, "Wrong size on UGameplayActuationComponent");
static_assert(offsetof(UGameplayActuationComponent, ActuationState) == 0x0000A8, "Member 'UGameplayActuationComponent::ActuationState' has a wrong offset!");
static_assert(offsetof(UGameplayActuationComponent, Transitions) == 0x0000C0, "Member 'UGameplayActuationComponent::Transitions' has a wrong offset!");
static_assert(offsetof(UGameplayActuationComponent, bEnableTransitions) == 0x0000D0, "Member 'UGameplayActuationComponent::bEnableTransitions' has a wrong offset!");

// Class GameplayInteractionsModule.GameplayInteractionStateTreeSchema
// 0x0020 (0x0048 - 0x0028)
class UGameplayInteractionStateTreeSchema final : public UStateTreeSchema
{
public:
	TSubclassOf<class AActor>                     ContextActorClass;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     SmartObjectActorClass;                             // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FStateTreeExternalDataDesc>     ContextDataDescs;                                  // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayInteractionStateTreeSchema">();
	}
	static class UGameplayInteractionStateTreeSchema* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayInteractionStateTreeSchema>();
	}
};
static_assert(alignof(UGameplayInteractionStateTreeSchema) == 0x000008, "Wrong alignment on UGameplayInteractionStateTreeSchema");
static_assert(sizeof(UGameplayInteractionStateTreeSchema) == 0x000048, "Wrong size on UGameplayInteractionStateTreeSchema");
static_assert(offsetof(UGameplayInteractionStateTreeSchema, ContextActorClass) == 0x000028, "Member 'UGameplayInteractionStateTreeSchema::ContextActorClass' has a wrong offset!");
static_assert(offsetof(UGameplayInteractionStateTreeSchema, SmartObjectActorClass) == 0x000030, "Member 'UGameplayInteractionStateTreeSchema::SmartObjectActorClass' has a wrong offset!");
static_assert(offsetof(UGameplayInteractionStateTreeSchema, ContextDataDescs) == 0x000038, "Member 'UGameplayInteractionStateTreeSchema::ContextDataDescs' has a wrong offset!");

// Class GameplayInteractionsModule.GameplayTask_MoveTo
// 0x01B8 (0x0218 - 0x0060)
class UGameplayTask_MoveTo : public UGameplayTask
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRequestFailed;                                   // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(EGameplayTaskActuationResult Result, class AActor* Actor)> OnCompleted;                                       // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayActuationComponent*            ActuationComponent;                                // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIMoveRequest                         MoveRequest;                                       // 0x0098(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x120];                                     // 0x00E8(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTask*                          StartTransitionTask;                               // 0x0208(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayTask*                          EndTransitionTask;                                 // 0x0210(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UGameplayTask_MoveTo* MoveTo(class AActor* Actor, const struct FVector& GoalLocation, class AActor* GoalActor, const EGameplayTaskMoveToIntent EndOfPathIntent, float AcceptanceRadius, EAIOptionFlag StopOnOverlap, EAIOptionFlag AcceptPartialPath, bool bUsePathfinding, bool bUseContinuousGoalTracking, EAIOptionFlag ProjectGoalOnNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_MoveTo">();
	}
	static class UGameplayTask_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_MoveTo>();
	}
};
static_assert(alignof(UGameplayTask_MoveTo) == 0x000008, "Wrong alignment on UGameplayTask_MoveTo");
static_assert(sizeof(UGameplayTask_MoveTo) == 0x000218, "Wrong size on UGameplayTask_MoveTo");
static_assert(offsetof(UGameplayTask_MoveTo, OnRequestFailed) == 0x000068, "Member 'UGameplayTask_MoveTo::OnRequestFailed' has a wrong offset!");
static_assert(offsetof(UGameplayTask_MoveTo, OnCompleted) == 0x000078, "Member 'UGameplayTask_MoveTo::OnCompleted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_MoveTo, MovementComponent) == 0x000088, "Member 'UGameplayTask_MoveTo::MovementComponent' has a wrong offset!");
static_assert(offsetof(UGameplayTask_MoveTo, ActuationComponent) == 0x000090, "Member 'UGameplayTask_MoveTo::ActuationComponent' has a wrong offset!");
static_assert(offsetof(UGameplayTask_MoveTo, MoveRequest) == 0x000098, "Member 'UGameplayTask_MoveTo::MoveRequest' has a wrong offset!");
static_assert(offsetof(UGameplayTask_MoveTo, StartTransitionTask) == 0x000208, "Member 'UGameplayTask_MoveTo::StartTransitionTask' has a wrong offset!");
static_assert(offsetof(UGameplayTask_MoveTo, EndTransitionTask) == 0x000210, "Member 'UGameplayTask_MoveTo::EndTransitionTask' has a wrong offset!");

// Class GameplayInteractionsModule.GameplayTask_MoveToContextualAnim
// 0x0058 (0x0270 - 0x0218)
class UGameplayTask_MoveToContextualAnim final : public UGameplayTask_MoveTo
{
public:
	struct FGameplayActuationState_ContextualAnim NextState;                                         // 0x0218(0x0058)(Protected, NativeAccessSpecifierProtected)

public:
	static class UGameplayTask_MoveToContextualAnim* EnterContextualAnim(class AActor* Interactor, const class FName InteractorRole, class AActor* InteractableObject, const class FName InteractableObjectRole, const class FName SectionName, const class FName ExitSectionName, const class UContextualAnimSceneAsset* SceneAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_MoveToContextualAnim">();
	}
	static class UGameplayTask_MoveToContextualAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_MoveToContextualAnim>();
	}
};
static_assert(alignof(UGameplayTask_MoveToContextualAnim) == 0x000008, "Wrong alignment on UGameplayTask_MoveToContextualAnim");
static_assert(sizeof(UGameplayTask_MoveToContextualAnim) == 0x000270, "Wrong size on UGameplayTask_MoveToContextualAnim");
static_assert(offsetof(UGameplayTask_MoveToContextualAnim, NextState) == 0x000218, "Member 'UGameplayTask_MoveToContextualAnim::NextState' has a wrong offset!");

// Class GameplayInteractionsModule.GameplayTask_MoveToStandTransition
// 0x00E0 (0x0140 - 0x0060)
class UGameplayTask_MoveToStandTransition final : public UGameplayTask
{
public:
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0xC8];                                      // 0x0078(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_MoveToStandTransition">();
	}
	static class UGameplayTask_MoveToStandTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_MoveToStandTransition>();
	}
};
static_assert(alignof(UGameplayTask_MoveToStandTransition) == 0x000008, "Wrong alignment on UGameplayTask_MoveToStandTransition");
static_assert(sizeof(UGameplayTask_MoveToStandTransition) == 0x000140, "Wrong size on UGameplayTask_MoveToStandTransition");
static_assert(offsetof(UGameplayTask_MoveToStandTransition, MovementComponent) == 0x000070, "Member 'UGameplayTask_MoveToStandTransition::MovementComponent' has a wrong offset!");

// Class GameplayInteractionsModule.GameplayTask_PlayContextualAnim
// 0x01C0 (0x0220 - 0x0060)
class UGameplayTask_PlayContextualAnim final : public UGameplayTask
{
public:
	uint8                                         Pad_60[0x80];                                      // 0x0060(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRequestFailed;                                   // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(EGameplayTaskActuationResult Result, class AActor* Actor)> OnCompleted;                                       // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         SectionIdx;                                        // 0x0100(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AnimSetIdx;                                        // 0x0104(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTransform>                     Pivots;                                            // 0x0108(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UContextualAnimSceneAsset*              SceneAsset;                                        // 0x0118(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InteractorRole;                                    // 0x0120(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InteractableObject;                                // 0x0128(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InteractableObjectRole;                            // 0x0130(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ExitSectionName;                                   // 0x0134(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UContextualAnimSceneInstance*           SceneInstance;                                     // 0x0138(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayActuationComponent*            ActuationComponent;                                // 0x0140(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FContextualAnimStartSceneParams        SceneParams;                                       // 0x0148(0x0068)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             SafeExitPoint;                                     // 0x01B0(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayContextualAnimStatus                     Status;                                            // 0x0210(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeleportOnTaskEnd;                                // 0x0211(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_212[0xE];                                      // 0x0212(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameplayTask_PlayContextualAnim* PlayContextualAnim(class AActor* Interactor, const class FName InteractorRole_0, class AActor* InteractableObject_0, const class FName InteractableObjectRole_0, const class FName SectionName, const class FName ExitSectionName_0, const class UContextualAnimSceneAsset* SceneAsset_0);

	void OnSectionEndTimeReached(class UContextualAnimSceneInstance* SceneInstance_0);
	void SetExit(EPlayContextualAnimExitMode ExitMode, class FName NewExitSectionName);

	EPlayContextualAnimStatus GetStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_PlayContextualAnim">();
	}
	static class UGameplayTask_PlayContextualAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_PlayContextualAnim>();
	}
};
static_assert(alignof(UGameplayTask_PlayContextualAnim) == 0x000010, "Wrong alignment on UGameplayTask_PlayContextualAnim");
static_assert(sizeof(UGameplayTask_PlayContextualAnim) == 0x000220, "Wrong size on UGameplayTask_PlayContextualAnim");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, OnRequestFailed) == 0x0000E0, "Member 'UGameplayTask_PlayContextualAnim::OnRequestFailed' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, OnCompleted) == 0x0000F0, "Member 'UGameplayTask_PlayContextualAnim::OnCompleted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, SectionIdx) == 0x000100, "Member 'UGameplayTask_PlayContextualAnim::SectionIdx' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, AnimSetIdx) == 0x000104, "Member 'UGameplayTask_PlayContextualAnim::AnimSetIdx' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, Pivots) == 0x000108, "Member 'UGameplayTask_PlayContextualAnim::Pivots' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, SceneAsset) == 0x000118, "Member 'UGameplayTask_PlayContextualAnim::SceneAsset' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, InteractorRole) == 0x000120, "Member 'UGameplayTask_PlayContextualAnim::InteractorRole' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, InteractableObject) == 0x000128, "Member 'UGameplayTask_PlayContextualAnim::InteractableObject' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, InteractableObjectRole) == 0x000130, "Member 'UGameplayTask_PlayContextualAnim::InteractableObjectRole' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, ExitSectionName) == 0x000134, "Member 'UGameplayTask_PlayContextualAnim::ExitSectionName' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, SceneInstance) == 0x000138, "Member 'UGameplayTask_PlayContextualAnim::SceneInstance' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, ActuationComponent) == 0x000140, "Member 'UGameplayTask_PlayContextualAnim::ActuationComponent' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, SceneParams) == 0x000148, "Member 'UGameplayTask_PlayContextualAnim::SceneParams' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, SafeExitPoint) == 0x0001B0, "Member 'UGameplayTask_PlayContextualAnim::SafeExitPoint' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, Status) == 0x000210, "Member 'UGameplayTask_PlayContextualAnim::Status' has a wrong offset!");
static_assert(offsetof(UGameplayTask_PlayContextualAnim, bTeleportOnTaskEnd) == 0x000211, "Member 'UGameplayTask_PlayContextualAnim::bTeleportOnTaskEnd' has a wrong offset!");

// Class GameplayInteractionsModule.GameplayTask_StandAt
// 0x00C8 (0x0128 - 0x0060)
class UGameplayTask_StandAt final : public UGameplayTask
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRequestFailed;                                   // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(EGameplayTaskActuationResult Result, class AActor* Actor)> OnCompleted;                                       // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x98];                                      // 0x0088(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UGameplayTask_StandAt* StandAt(class APawn* Pawn, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_StandAt">();
	}
	static class UGameplayTask_StandAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_StandAt>();
	}
};
static_assert(alignof(UGameplayTask_StandAt) == 0x000008, "Wrong alignment on UGameplayTask_StandAt");
static_assert(sizeof(UGameplayTask_StandAt) == 0x000128, "Wrong size on UGameplayTask_StandAt");
static_assert(offsetof(UGameplayTask_StandAt, OnRequestFailed) == 0x000068, "Member 'UGameplayTask_StandAt::OnRequestFailed' has a wrong offset!");
static_assert(offsetof(UGameplayTask_StandAt, OnCompleted) == 0x000078, "Member 'UGameplayTask_StandAt::OnCompleted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_StandAt, MovementComponent) == 0x000120, "Member 'UGameplayTask_StandAt::MovementComponent' has a wrong offset!");

// Class GameplayInteractionsModule.GameplayTask_StandToMoveTransition
// 0x00E0 (0x0140 - 0x0060)
class UGameplayTask_StandToMoveTransition final : public UGameplayTask
{
public:
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0xC8];                                      // 0x0078(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_StandToMoveTransition">();
	}
	static class UGameplayTask_StandToMoveTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_StandToMoveTransition>();
	}
};
static_assert(alignof(UGameplayTask_StandToMoveTransition) == 0x000008, "Wrong alignment on UGameplayTask_StandToMoveTransition");
static_assert(sizeof(UGameplayTask_StandToMoveTransition) == 0x000140, "Wrong size on UGameplayTask_StandToMoveTransition");
static_assert(offsetof(UGameplayTask_StandToMoveTransition, MovementComponent) == 0x000070, "Member 'UGameplayTask_StandToMoveTransition::MovementComponent' has a wrong offset!");

// Class GameplayInteractionsModule.GameplayTask_SuddenTurnTransition
// 0x00E0 (0x0140 - 0x0060)
class UGameplayTask_SuddenTurnTransition final : public UGameplayTask
{
public:
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0xC8];                                      // 0x0078(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_SuddenTurnTransition">();
	}
	static class UGameplayTask_SuddenTurnTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_SuddenTurnTransition>();
	}
};
static_assert(alignof(UGameplayTask_SuddenTurnTransition) == 0x000008, "Wrong alignment on UGameplayTask_SuddenTurnTransition");
static_assert(sizeof(UGameplayTask_SuddenTurnTransition) == 0x000140, "Wrong size on UGameplayTask_SuddenTurnTransition");
static_assert(offsetof(UGameplayTask_SuddenTurnTransition, MovementComponent) == 0x000070, "Member 'UGameplayTask_SuddenTurnTransition::MovementComponent' has a wrong offset!");

}

